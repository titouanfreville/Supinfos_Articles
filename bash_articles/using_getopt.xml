<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<section>
  <title>Créer des applications avec Bash et GetOpt</title>
  <para/>
  <section>
    <title>Introduction</title>

    <para/>

    <para>
      Vous aimez les terminaux bash ? Vous aimez automatiser toutes vos tâches récurrentes et voudriez les partager avec d'autres ? Ou tout simplement, vous voulez créer une mini-application en bash ? Cet article est fait pour vous. Il vous expliquera comment créer des applications bash simple avec options commande et arguments. Comme un vrai programme quoi.  
    </para>
    <para/>

    <para>
      Dans un premier temps, je vais fixer quelque pré-requis pour cet article. Je vous invite également à travailler depuis un environnement Linux avec bash d'installer, et d'ajouter un répertoire `~/bin` ou autre à votre path (`export PATH=$PATH:=REPO_TO_WORKING_SCRIPT`). 
    </para>

    <para/>
  </section>
  <section>
    <title>Pré-requis</title>
    <para/>
    <para>
      A titre personnelle, j'ai utilisé et créer des programmes bash utilisant getopt uniquement pour des terminaux Mac et Linux. Je ne suis pas sur de son support par le shell Windows.
    </para>
    <section>
      <title>Pré-requis Linux</title>
      <para>
        Il n'y a pas vraiment de pré-requis sous les systèmes Linux. Théoriquement, getopt devrait être installé par défaut. Je vous recommande tout de même de vérifier sa présence avec un `getopt --version`. Si il n'est pas installé, faite-le. Je vous recommande également de créer un répertoire bin dans votre dossier local et d'éditer votre fichier `.bashrc` pour ajouter au path le répertoire bin et pouvoir l'oublier. Ensuite, pensez à placer tous vos scripts bash dans ce répertoire et à les rendre exécutables. Ceci vous permettra de ne pas avoir à préciser la localisation du fichier pour l'exécuter.
      </para>
    </section>
    <section>
      <title>Pré-requis MacOS</title>
      <para>
        Sous mac, il est impératif d'installer gnu-getopt si vous voulez pouvoir supporter l'utilisation d'argument long. Si vous ne voulez pas ajouter cette dépendances à vos programme, n'utilisez que les arguments court devrait vous permettre d'utiliser le getopt natif. Encore une fois, quelque soit la solution choisie, vérifier les installations. Et encore une fois, vous pouvez ajouter un répertoire à votre PATH pour simplifier l'exécution de vos script. 
      </para>
    </section>
    <para></para>
    <para>Je n'ai pas de recommandation spécifiques au sujet des éditeurs de textes, assurez vous seulement que celui que vous préférez supporte la coloration syntaxique pour bash. Personnellement, j'utilise sublimetext ou atome.</para>
    <para></para>
    <para>
      Je vais vous guider à travers différentes étapes : 
      <itemizedlist>
        <listitem>
          Premier pas : Les bases de bash. 
        </listitem>
        <listitem>
          GetOpt : le concept et les bases
        </listitem>
        <listitem>
          Fonctionnalité avancé et création d'un programme simple. 
        </listitem>
      </itemizedlist>
    </para>
    <para/>
  </section>
  <section>
    <title>Découvrons bash</title>
    <para/>
    <section>
      <title>A petits pas</title>
      <para/>
      <para>
        Tout d'abord, il faut rappeler que la programmation en bash est une programmation de type impérative. Nous savons donc ce que la machine fait, mais pas comment ;). Nous retrouvons bien évidemment toute les structures classiques de la programmation impérative, à savoir les boucles, la création de fonctions et la création de variables. Cependant, bash est avant tout un langage de scripting, c'est à dire que son objectif principal est de lancer d'autre programme permettant de réaliser quelque chose. Si il est possible de réaliser des opérations mathématiques simple, le processus est tout de même assez lourd. Cependant, savoir réaliser ce type d'opération peut s'avérer plus qu'utiles. Ainsi, l'objectif de cette première partie sera de créer un menu simple permettant de lancer une calculatrice ou l'écriture d'une citation quelconque.  
      </para>
      <para></para>
      <section>
        <title>Pré-requis de la partie</title>
        <para />
        <para>
          <itemizedlist>
            <listitem>Un environnement disposant d'un terminal bash (sous Mac : ouvrir le terminal puis entrer la commande bash).</listitem>
            <listitem>Installer fortune et figlet (figlet permet de styler les outputs bash et fortune et un générateur de citations). A défaut, nous verrons comment créer une "base" de citation</listitem>
          </itemizedlist>
        </para>
      </section>
      <section>
        <title>Le concept</title>
        <para/>
        <para>
          Nous allons donc d'abord faire un "petit" script bash avec menu. Comme dit précédemment, ce script à pour but de laisser le choix à l'utilisateur entre faire un calcul ou voir une citation. Ce script va donc être composer de 3 parties. La première partie, la plus simple, est celle du générateur de citation. En effet, on utilise pour cela le paquet fortune déjà existant. La deuxième est la partie menu car plus facile à réaliser dans le cadre d'un script bash. Enfin, viendra la partie calcul. Pour chaque partie, nous détaillerons le fonctionnement de la fonctions afin de vous initier au langage. Si vous êtes déjà familier avec bash, vous pouvez passer directement à l'introduction de getopt.
        </para>
      </section>
      <section>
        <title>Afficher une citation</title>
        <para/>
        <para>
          Créons donc notre première fonctions. Tout d'abord, nous allons créer un fichier bash appelé `simple_menu.sh` par exemple. La première de ce menu doit contenir l'instruction <programlisting langage="bash">#!/bin/bash</programlisting> ou <programlisting langage="bash"> #!/env/bash </programlisting>. Tous deux demandant à ce que le script soit utiliser en bash. Si vous ne préciser pas ce commentaire et que vous êtes dans un autre système de shell (eg: la console mac), le script pourrait rencontrer des erreurs. Ensuite, nous allons créer la fonctionnalité de génération de citations. Pour cela, nous allons simplement ajouter <programlisting langage="bash">figlet $(fortune)"</programlisting>. Ce qui nous donnera le fichier suivant : 
          <programlisting language="bash">
            #!/bin/bash
            figlet "$(fortune"
          </programlisting>
          Vous pouvez exécuter ce programme, ce qui devrait vous donner quelque chose comme : 
          <mediaobject>
            <imageobject>
              <imagedata fileref='http://freville.iiens.net/images/filget_output.png' />
            </imageobject>
          </mediaobject>
        </para>
        <para/> 
        <para>
          Ce qui se passe :<br/> 
          Lors de l'appel au script, votre script va se lancer dans un environnement bash (étapes non visibles). Ensuite, il va arriver sur la commande figlet. Figlet est une commande prenant un texte en argument et renvoyant ce même texte mais avec une stylisation particulière. Ici, le texte est représenté par "$(fortune)". Ce "$(fortune)" est une fonction. Les " " sont obligatoire afin de considérer ce qu'il y a à l'intérieur de celle ci comme étant une seule entité. Ensuite le $( XXXX ) représente ce qui est renvoyer par la fonction XXXX (ici fortune). Nous demandons donc de passer à figlet le retour de la fonction fortune. Fortune est une fonction bash qui renvoie une citation quelconque. 
        </para>
        <para>
          Maintenant, que faire si l'utilisateur ne dispose pas de figlet et/ou fortune (ce qui est probablement le cas car ce en sont pas des utilitaires basique). Nous devrions les remplacer par notre propre "système". Pour cela, il nous faut d'abord savoir si les programmes existent. Pour cela, nous allons utiliser le fait que la plus part des programmes bash ont un argument -v permettant de connaître la version installé du programme. Cette fonction va afficher la version actuelle du programme demandé si celui existe (et renvoyer un code 0), sinon, une erreur et un code retour non nulle. Nous allons donc tester l'existence des programmes ainsi : 
          <programlisting language="bash">
            figlet -v &gt; /dev/null 2&gt; /dev/null &amp;&amp; FIGLET_INSTALLED=0 || FIGLET_INSTALLED=1
            fortune -v &gt; /dev/null 2&gt; /dev/null &amp;&amp; FORTUNE_INSTALLED=0 || FORTUNE_INSTALLED=1
          </programlisting>
          Ici, nous appelons l'option -v des programmes figlet puis fortune. Afin d'éviter de voir lors de l'exécution du programme la sortie de ces fonctions ou leurs erreurs (qui ne nous intéressent pas ici), nous demandons à ce qu'elles soient rediriger vers /dev/null (le trou noir de bash). Pour cela, nous utilisons l'opérateur &gt; qui dirige la sortie demandé à gauche vers l'argument placer à droite. Appeler sans chiffre, il redirige la sortie global du programme, mais il restent l'affichage des erreurs systèmes (quand le programmes n'existent pas) qui sont sur la sortie d'erreur standard. Cette sortie est numéroté 2. 2&gt; /dev/null redirige donc la sortie standard d'erreur, pendant la duré de la fonction, vers notre trou noir. Ensuite, si la fonction réussi, nous stockons la valeur 0 dans la variable FIGLET_INSTALLED, 1 sinon. Et nous avons récupérer l'information qui nous intéresser (la présence ou non des programmes figlet et fortune).  
        </para>
        <para/>
        <para>
          Reste à utiliser ce résultat. Nous allons donc dire que si c'est programme sont installés, nous réutilisons le code de tout à l'heure. Et sinon, que fait-on ? 
        </para>
        <para/>
        <para>
          Dans le cas ou figlet est manquant, il peut être remplacer par la fonction echo, fonction basique de bash pour renvoyer quelque chose dans la sortie standard. Si fortune est manquant, il nous faut trouver une solution pour obtenir des citations aléatoire. 
        </para>
        </para>
        <para>
          Implémentons donc notre "générateur" de citation. Pour cela, nous allons utiliser la fonction $RANDOM de bash dont nous allons stocker le résultat dans une variable. Puis faire un case sur la valeur de cette variable et dans certains cas, mettre une citation particulière. Ce qui va donner :
          <programlisting langage="bash">
            get_citation () {
              citation_indice=$((RANDOM%4))
              case $citation_indice in
                0) echo "Noob, je suis un noob. Un no-life un vrai. Je joue au MMORPG";;
                1) echo "42";;
                2) echo "Si l'école sa rendait les hommes libres et égaux, le gouvernement déciderait que c'est pas bon pour les marmots.";;
                *) echo "Insérer citation ici";;
              esac
            }
          </programlisting>
          Nous voici donc avec une fonction bash appelée get_citation, renvoyant une citation aléatoire. Un fortune en moins complet en fait ;). Si vous désirez pouvoir mettre plus de citation, il vous faudra modifier la valeur du modulo (%) pour autre chose que 4. Le bloc case VALEUR in ... esac permet d'attribuer à des valeurs de VALEUR une action. L'utilisation des ;; est obligatoire pour signifier la fin d'un cas.  
        </para>
        <para/>
        <para>
          Maintenant que nous avons nos fonctions de remplacement, utilisons les et modifions notre simple_menu.sh pour ajouter ces dernières fonctionnalités. 
          <programlisting langage="bash">
            #!/bin/bash

            get_citation () {
              citation_indice=$((RANDOM%4))
              case $citation_indice in
                0) echo "Noob, je suis un noob. Un no-life un vrai. Je joue au MMORPG";;
                1) echo "42";;
                2) echo "Si l'école sa rendait les hommes libres et égaux, le gouvernement déciderait que c'est pas bon pour les marmots.";;
                *) echo "Insérer citation ici";;
              esac
            }

            figlet -v &gt; /dev/null 2&gt; /dev/null &amp;&amp; FIGLET_INSTALLED=0 || FIGLET_INSTALLED=1
            fortune -v &gt; /dev/null 2&gt; /dev/null &amp;&amp; FORTUNE_INSTALLED=0 || FORTUNE_INSTALLED=1

            if [[ $FORTUNE_INSTALLED -eq 0 ]]
              then CITATION="$(fortune)"
              else CITATION="$(get_citation)"
            fi

            [ $FIGLET_INSTALLED -eq 0 ] &amp;&amp;  figlet -nt "$CITATION" || echo "$CITATION"
          </programlisting>
        </para>
        <para/>
        <para>
          And know, let's make it as functions only :) 
          <programlisting langage="bash">
            #!/bin/bash

              get_citation () {
                citation_indice=$((RANDOM%4))
                case $citation_indice in
                  0) echo "Noob, je suis un noob. Un no-life un vrai. Je joue au MMORPG";;
                  1) echo "42";;
                  2) echo "Si l'école sa rendait les hommes libres et égaux, le gouvernement déciderait que c'est pas bon pour les marmots.";;
                  *) echo "Insérer citation ici";;
                esac
              }

              print_citation () { 
                figlet -v &gt; /dev/null 2&gt; /dev/null &amp;&amp; FIGLET_INSTALLED=0 || FIGLET_INSTALLED=1
                fortune -v &gt; /dev/null 2&gt; /dev/null &amp;&amp; FORTUNE_INSTALLED=0 || FORTUNE_INSTALLED=1

                if [[ $FORTUNE_INSTALLED -eq 0 ]]
                  then CITATION="$(fortune)"
                  else CITATION="$(get_citation)"
                fi

                [ $FIGLET_INSTALLED -eq 0 ] &amp;&amp; figlet -nt "$CITATION" || echo "$CITATION"
              }

              print_citation
          </programlisting>
          Oui, cela revient juste à déplacer le code qui était hors de la fonction dans une fonction puis à l'appeler pour pouvoir tester bien sur :).
        </para>
        <para/>
      </section>
      <para>
        Maintenant que nous avons nos citations, invitons un utilisateur à les essayer :)
      </para>
      <section>
        <title>Le Menu</title>
        <para/>
        <para>
          Donc, pour le menu, nous allons avoir besoin de poser une question à l'utilisateur puis obtenir une réponse. Pour ce faire, il va nous suffire d'afficher la question puis d'attendre la réponse de l'utilisateur. 
        </para>
        <para/>
        <para>
          Nous allons donc avoir le code : 
          <programlisting langage="bash">
            #!/bin/bash

            get_citation () {
              local citation_indice=$((RANDOM%4))
              case $citation_indice in
                0) echo "Noob, je suis un noob. Un no-life un vrai. Je joue au MMORPG";;
                1) echo "42";;
                2) echo "Si l'école sa rendait les hommes libres et égaux, le gouvernement déciderait que c'est pas bon pour les marmots.";;
                *) echo "Insérer citation ici";;
              esac
            }

            print_citation () { 
              figlet -v $gt; /dev/null 2$gt; /dev/null &amp;&amp; FIGLET_INSTALLED=0 || FIGLET_INSTALLED=1
              fortun -v $gt; /dev/null 2$gt; /dev/null &amp;&amp; FORTUNE_INSTALLED=0 || FORTUNE_INSTALLED=1

              if [[ $FORTUNE_INSTALLED -eq 0 ]]
                then CITATION="$(fortune)"
                else CITATION="$(get_citation)"
              fi

              [ $FIGLET_INSTALLED -eq 0 ] &amp;&amp; figlet -nt "$CITATION" || echo "$CITATION"
            }

            menu () {
              local action_choice="1 - Calculer quelque chose ? 
            2 - Etre éclairer par la sagesse de tes ancêtres ? 
            3 - Epingle Jésus à sa croix ?"
              local question="Bonjour, jeune scarabée. Dieu te parle et te propose de trouver la voie. As-tu besoin de"
              local not_an_option="Désolé, mais je n'ai pas compris le sens profond de ton interrogation ? Veux-tu ?"
              clean=${1:-0}
              [ $clean -eq 0 ] &amp;&amp; echo "$question" || echo "$not_an_option"
              echo "$action_choice"
              read -r -n 1 -p "" reponse
              echo
              case "$reponse" in 
                "1") echo "Calculer n'est pas encore à ta portée. ";;
                "2") print_citation;;
                "3") exit 1;;
                *) return 2;;
              esac
            }

            menu
          </programlisting>
        </para>
        <para/>
        <para>
          Nous voila donc capable d'écouter notre utilisateur. Celui-ci peut donc demander à faire un calcul, afficher une citation, quitter le programme (exit 1) ou dire qu'il n'a pas compris la demande (return 2). La différence entre exit et return va nous être utile maintenant, puisque nous allons intégrer ce menu à une boucle d’interaction. Une telle boucle est souvent définie avec un while true, ce qui nous pose la question de comment en sortir. J'ai donc deux cas de sortie forcée de ma fonction menu : exit 1 ou return 2. Le exit 1 va permettre de couper la boucle car nous demandons à bash d'arrêter l'exécution du script. Le return 2 va nous permettre de récupérer un code de sortie non nulle sans quitter la boucle. Ceci va nous permettre de pouvoir donner en argument à l'appel de menu un paramètre permettant de savoir si il doit afficher le message sans erreur ou le message d'erreur.
        </para>
        <para/>
        <para>
          Avec la boucle d'interaction, nous aurons : 
          <programlisting language="bash">
            #!/bin/bash

            get_citation () {
              local citation_indice=$((RANDOM%4))
              case $citation_indice in
                0) echo "Noob, je suis un noob. Un no-life un vrai. Je joue au MMORPG";;
                1) echo "42";;
                2) echo "Si l'école sa rendait les hommes libres et égaux, le gouvernement déciderait que c'est pas bon pour les marmots.";;
                *) echo "Insérer citation ici";;
              esac
            }

            print_citation () { 
              figlet -v &gt; /dev/null 2&gt; /dev/null &amp;&amp; FIGLET_INSTALLED=0 || FIGLET_INSTALLED=1
              fortun -v &gt; /dev/null 2&gt; /dev/null &amp;&amp; FORTUNE_INSTALLED=0 || FORTUNE_INSTALLED=1

              if [[ $FORTUNE_INSTALLED -eq 0 ]]
                then CITATION="$(fortune)"
                else CITATION="$(get_citation)"
              fi

              [ $FIGLET_INSTALLED -eq 0 ] &amp;&amp; figlet -nt "$CITATION" || echo "$CITATION"
            }

            menu () {
              local action_choice="1 - Calculer quelque chose ? 
            2 - Etre éclairer par la sagesse de tes ancêtres ? 
            3 - Epingle Jésus à sa croix ?"
              local question="Bonjour, jeune scarabée. Dieu te parle et te propose de trouver la voie. As-tu besoin de"
              local not_an_option="Désolé, mais je n'ai pas compris le sens profond de ton interrogation ? Veux-tu ?"
              clean=${1:-0}
              [ $clean -eq 0 ] &amp;&amp; echo "$question" || echo "$not_an_option"
              echo "$action_choice"
              read -r -n 1 -p "" reponse
              echo
              case "$reponse" in 
                "1") echo "Calculer n'est pas encore à ta portée. ";;
                "2") print_citation;;
                "3") exit 1;;
                *) return 2;;
              esac
            }

            while true 
            do
              clean=${clean:-0}
              echo
              menu $clean
              clean=$?
              echo
            done
          </programlisting>
        </para>
        <para/>
        <para>
          Voici donc un petit soft simple déjà. Mais il lui manque encore une légère fonctionnalité... La calculette :)
        </para>
      </section>
      <section>
        <title>La calculette</title>
        <para/>
        <para>
          Pour la calculatrice, nous avons plusieurs options. Soit nous récupérons l'entré utilisateur pour la passer en calcul. Soit nous demandons à l'utilisateur l'opération qu'il veut effectuer puis les opérandes nécessaires. Nous allons choisir la plus simple, à savoir injecter l'entrée utilisateur dans une option de calcul.
        </para>
        <para/>
        <para>
          En bash, pour pouvoir effectuer un calcul, il nous faut l'appeler ainsi : $[CALCUL]. Ainsi, pour effectuer l'opération 1+1, il nous faut écrire $[1+1]. Il est possible de mettre n'importe qu'elle chaîne d'opération standard, la priorité est respecté. Ainsi, notre fonction de calcul sera simplement 
          <programlisting language="bash">
            calcul () {
              read -r -p 'Entrez votre calcul : ' response
              echo $[$response]
            }
          </programlisting>
          Et oui, c'est la fonction la plus simple en fait :p 
        </para>
        <para/>
        <para>
          Le mini-soft complet donne donc : 
          <programlisting language="bash">
            #!/bin/bash

            get_citation () {
              local citation_indice=$((RANDOM%4))
              case $citation_indice in
                0) echo "Noob, je suis un noob. Un no-life un vrai. Je joue au MMORPG";;
                1) echo "42";;
                2) echo "Si l'école sa rendait les hommes libres et égaux, le gouvernement déciderait que c'est pas bon pour les marmots.";;
                *) echo "Insérer citation ici";;
              esac
            }

            print_citation () { 
              figlet -v &gt; /dev/null 2&gt; /dev/null &amp;&amp; FIGLET_INSTALLED=0 || FIGLET_INSTALLED=1
              fortun -v &gt; /dev/null 2&gt; /dev/null &amp;&amp; FORTUNE_INSTALLED=0 || FORTUNE_INSTALLED=1

              if [[ $FORTUNE_INSTALLED -eq 0 ]]
                then CITATION="$(fortune)"
                else CITATION="$(get_citation)"
              fi

              [ $FIGLET_INSTALLED -eq 0 ] &amp;&amp; figlet -nt "$CITATION" || echo "$CITATION"
            }
            
            calcul () {
              read -r -p 'Entrez votre calcul : ' response
              echo $[$response]
            }

            menu () {
              local action_choice="1 - Calculer quelque chose ? 
            2 - Etre éclairer par la sagesse de tes ancêtres ? 
            3 - Epingle Jésus à sa croix ?"
              local question="Bonjour, jeune scarabée. Dieu te parle et te propose de trouver la voie. As-tu besoin de"
              local not_an_option="Désolé, mais je n'ai pas compris le sens profond de ton interrogation ? Veux-tu ?"
              clean=${1:-0}
              [ $clean -eq 0 ] &amp;&amp; echo "$question" || echo "$not_an_option"
              echo "$action_choice"
              read -r -n 1 -p "" reponse
              echo
              case $reponse in 
                1) calcul;;
                2) print_citation;;
                3) exit 1;;
                *) return 2;;
              esac
            }

            while true 
            do
              clean=${clean:-0}
              echo
              menu $clean
              clean=$?
              echo
            done
          </programlisting>
        </para>
      </section>
    </section>
  </section>
  <para/>
  <para>
    Voici donc pour cet article. J'espère que vous aurez appris de nouvelles choses :) Je vous laisse les liens vers les sources utilisées pour faire cet article et mon répertoire git où vous pourrez retrouver tous les fichiers de codes présenter ici. 
  </para>
  <para>
    <itemizedlist>
      <listitem>
         <ulink href = "http://caml.inria.fr/ocaml/index.fr.html">Élixir, page officielle</ulink>
      </listitem>
      <listitem>
        <ulink href = "https://fr.wikipedia.org/wiki/Programmation_fonctionnelle">La programmation fonctionnelle, version wikipédia</ulink>
      </listitem>
      <listitem>
        <ulink href = "http://deptinfo.unice.fr/~roy/progfonc.html">La programmation fonctionnelle, version Paul Graham</ulink>
      </listitem>
      <listitem>
        <ulink href = "http://github.com/titouanfreville/Supinfos_Articles/tree/master/ocaml_article/ressources">Les codes de l'article</ulink>
      </listitem>
    </itemizedlist>
  </para>
  <para/>
</section>
