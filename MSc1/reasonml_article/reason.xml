<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<section>
  <title>La programmation fonctionnelle et Reason</title>
  <para/>
  <section>
    <title>Introduction</title>
    <para/>
    <para>
      Cet article a pour but de vous présenter un nouveau langage (Reason <ulink url="https://facebook.github.io/reason/">https://facebook.github.io/reason/-</ulink>) et le concept de programmation fonctionnelle.
    </para><para>
      Je vais tout d'abord rappeler ce qu'est la programmation fonctionnelle. Je vous invite à consulter les cours et vidéos à ce sujet si vous avez accès aux ressources de Supinfo pour plus de détails (cf 3AIT notamment) ainsi que les articles suivants :
      <ulink url="https://fr.wikipedia.org/wiki/Programmation_fonctionnelle">https://fr.wikipedia.org/wiki/Programmation_fonctionnelle</ulink> et <ulink url="http://deptinfo.unice.fr/~roy/progfonc.html">http://deptinfo.unice.fr/~roy/progfonc.html</ulink> 
    </para>
    <para/>
  </section>
  <section>
    <title>La programmation fonctionnelle, en bref.</title>
    <para/>
    <para>
      Il est plus simple de parler de programmation fonctionnelle par opposition à la programmation impérative, plus connue et abordée plus tôt dans les programmes scolaires. Si vous ne savez pas ce qu'est la programmation impérative, je vous invite à ignorer ce paragraphe pour passer directement à l'introduction de Reason après avoir lue ou regarder les articles et ressources précédemment citées.
    </para>
    <section>
      <title>Concept de programmation fonctionnelle.</title>
      <para>
        La programmation fonctionnelle est un concept de programmation ayant pour but principal de s'affranchir des problèmes d'affectation présent dans la programmation impérative. Ainsi, en programmation fonctionnelle, nous n'utilisons plus des états de la machine (ex : x=1 =&gt; J'ai créé un entier référencé par x dont la valeur est 1 donc ma machine est dans l'état X. x++ -&gt;x vaut maintenant 2, ma machine est dans un nouvel état Y) mais des fonctions imbriquées. La principale différence étant que : En programmation fonctionnelle, je sais exactement ce que FAIT mon programme et comment il évolue LOGIQUEMENT (essentiellement basée sur les concepts de récursion en mathématique) tandis qu'en programmation impérative, je sais dans quel état est ma machine, ce qui est présent en mémoire (à quel endroit dans les langages de plus bas niveaux) et quel état je dois atteindre. D'un côté, je sais COMMENT mon programme fonctionne (impératif), de l'autre, je sais POURQUOI et je peux le démontrer (fonctionnel).
      </para><para>
        Une autre différence : il est possible, en programmation impérative, de modifier plusieurs Pointeurs dans une même fonction (et donc d'avoir d'une certaine façon, une fonction qui 'retourne' plusieurs valeurs). C'est impossible en programmation fonctionnelle. Une fonction en programmation fonctionnelle prend des ensembles d'arguments (liste, tuples, singleton, etc.) et ne retourne qu'un seul ensemble.
      </para>
    </section>
    <section>
      <title>Utilisations de la programmation fonctionnelle.</title>
      <para/>
      <para>
        La programmation fonctionnelle est aujourd'hui principalement utilisée dans deux domaines :
        <itemizedlist>
          <listitem>
            <para>
              Les preuves, démonstrations et calculs dans le domaine scientifique (ex : démontrer la validité d'un concept mathématique)
            </para>
          </listitem>
          <listitem>
            <para>
              L'intelligence artificielle (IA). (cf cours 3AIT)
            </para>
          </listitem>
        </itemizedlist>
        Pourquoi ces deux domaines ? Pour la partie scientifique, les langages de programmation fonctionnelle cherchant à être aussi proches que possible des bases mathématiques, il est logique de les utiliser pour des applications et programmes liés à ce domaine. Pour son utilisation en intelligence artificielle, l'IA est un domaine ou l'algorithmie occupe une place centrale. Or en programmation fonctionnelle, si l'algorithme implémenté fait ce que nous voulons et qu'il est correctement implémenté, nous pouvons être sûrs qu'il fera ce qu'il faut.
      </para>
    </section>
    <para/>
    <para>
      Cela étant fixé, présentons maintenant Reason.
    </para>
  </section>
  <section>
    <title>PRÉREQUIS</title>
    <para/>
    <para>
      Pour la suite du voyage, il vous faudra avoir : 
      <itemizedlist>
        <listitem>
          Avoir un éditeur de texte avec la coloration syntaxique pour Reason (parce que c'est plus agréables). J'utilise pour ma part Visual Studio Code. 
        </listitem>
        <listitem>
          Être prêt à souffrir ;)
        </listitem>
      </itemizedlist>
    </para>

    <para>
      Nous allons apprendre Reason en suivant les étapes suivantes :
      <itemizedlist>
        <listitem>
          Premiers pas : Faire une fonction arithmétique simple
        </listitem>
        <listitem>
          Manipuler les listes 
        </listitem>
        <listitem>
          Fonctions de tri sur les listes
        </listitem>
        <listitem>
          Résolution de problèmes de façon fonctionnelle (ex Tour de Hanoï)
        </listitem>
      </itemizedlist>
      Les codes seront présentés de façon réutilisable via la création de librairie. 
      Tout ce qui va être abordé par la suite sont des concepts et applications basiques de la programmation fonctionnelle.
    </para>
    <para/>
    <para>
      Mais tout d'abord, préparer votre environnement pour pouvoir travailler avec Reason. 
    </para>
    <para/>
  </section>
  <section>
    <title>Installer Reason</title>
    <para/>
    <para>
      Reason est un langage créé par Facebook. Il est très fortement basé sur Ocaml (cf : https://www.supinfo.com/articles/single/2710-programmation-fonctionnelle-ocaml), et 
      en reprend l'idéologie, a savoir, un typage fort et une gestion agréable des fonctions ;). Il y ajoute la facilité d'intégration dans les projets web récents en utilisant des 
      modules node JS et en étant lui-même un. L'objectif de Reason est donc d'accorder Ocaml et la programmation d'application web de façon plus harmonieuse. 
    </para>
    <para/>
    <para>
      Pour faire fonctioner Reason, vous allez donc devoir installer : 
      <itemizedlist>
        <listitem>NPM (version 3.10 min)</listitem>
        <listitem>NodeJS</listitem>
        <listitem>Ocaml</listitem>
        <listitem>Ocaml-libs</listitem>
      </itemizedlist>
    </para>
    <para/>
    <para>
      Une fois cela fait, je vous invite à récupérer le contenu suivant : 
      <ulink url="https://github.com/titouanfreville/reasonmldiscovery">
        base pour projet reason
      </ulink>, puis lancer un npm install.
    </para>
    <para/>
    <para>
      Nous voila prêt à découvrir la raison. 
    </para>
  </section>
  <section>
    <title>Jouons avec Raison</title>
    <para/>
    <section>
      <title>A petits pas</title>
      <para/>
      <para>
        Pour cette première expérience, nous allons créer deux fonctions mathématiques : factorielle (!) et puissance. Ces fonctions seront implémentées de deux façons : 
        avec des boucles (classique en impératif) en C, de façon récursive (idéologie fonctionnelle) en Reason. Mais tout d'abord, quelques rappels : 
        <itemizedlist>
          <listitem>
            <para>
              Reason est un langage dynamiquement typé. C'est-à-dire que le type de la variable est déterminé après son affectation. Il est cependant possible de forcer le type d'une variable. 
            </para>
          </listitem>
          <listitem>
            <para>
              Il faut manipuler les types avec précaution. En effet, chaque fonction attendra un certain type donné. Afin d'être le plus réutilisable possible, les fonctions proposées auront toujours une dépendance de type minimal (ex : une fonction d'addition sera typée pour être utilisable par tous floats même si elle utilisait principalement sur des entiers dans notre cas)...
            </para>
          </listitem>
          <listitem>
            <para>
              Reason est très fortement typée. Les opérateurs sont souvent spécifiques à un type donné. Par exemple, si vous travaillez sur des entiers, les opérateurs standards seront +, -, *, /. Mais sur des réels, ces opérateurs seront toujours suivis d'un point : +., -., *., /. . Aussi, 0 +. 1.5 renverra une erreur. Il faudra écrire 0. +3 1.5. 
            </para>
          </listitem>
          <listitem>
            <para>
              Afin que tous sachent les prérequis de chaque fonction et sont utilités, celles-ci seront commentées comme suit :    
              <programlisting langage="reason">
                /** @name: Nom_de_la_fonction
                *  @ Description_de_la_fonction
                * @parameter: Nom_du_paramètre Type Description
                * ....
                * @return: Description (Ce que retourne la fonction, dans quelle situation)
                * @throw: Erreur Description
                */
              </programlisting>
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para/>
      <section>
        <title>En mode Impératif</title>
        <section>
          <title>Théorie</title>
          <para>
            Nous avons dit plus haut que l'algorithme était essentiel en programmation fonctionnelle. Bien que ce ne soit pas le cas en programmation impérative, je vous propose de tout de même les écrire en pseudo-code afin d'avoir une base de comparaison pour les algorithmes donnés en fonctionnel.
          </para>
          <para>
            Les algorithmes impératifs permettant d'exécuter nos deux fonctions sont les suivants. 
          </para>
          <para>
            <programlisting>
              puissance :  
              Soit PUISSANCE (a,b) une fonction sur les entiers Naturels. 
              PUISSANCE (a,b) = 
              Soit res un entier tel que res = 1 
              SI b strictement plus petit que 1, Retourner res.  
              Si non 
              Pour i allant de 1 à b faire : 
                res = res * a  
              Fait;  
              Retourner res. 
            </programlisting>
          </para>
          
          <para>
            <programlisting>
              factorielle :  
              Soit FACTORIELLE (a) une fonction sur les entiers Naturels. 
              PUISSANCE (a,b) = 
              Soit res un entier tel que res = 1   
              Pour i allant de 1 à a faire : 
                res = res * a 
              Fait; 
              Retourner res.
            </programlisting>
          </para>
        </section>
        <section>
          <title>En C</title>
          <para>
            Implémentation en C
          </para>
          <para>
            <programlisting langage="c">
              int Puissance(int a, int b)  {
                int res=1;
                int i;
                for (i=1; i&gt;b;i++) {
                  res=res*b;
                }
                return res;
              }
            </programlisting>
          </para>
          <para>
            <programlisting langage="c">
              int Factorielle(int a)  {
                int res=1;
                int i;
                for (i=0; i&gt;a;i++) {
                  res=res*i;
                }
                return res;
              }
            </programlisting>
          </para>
        </section>
      </section>
      <section>
        <title>En fonctionnel</title>
        <section>
          <title>Algorithme</title>
          <para>
            Les algorithme fonctionnels sont les suivants :
          </para>
          <para>
            <programlisting>
              puissance: 
              Soit PUISSANCE (a,b) une fonction sur les entiers Naturels,  
              PUISSANCE (a,b) = SELON b   
              b = 0 -&gt; 1  
              b -&gt; a*PUISSANCE (a,b-1) 
            </programlisting>
          </para>
          <para>
            L'idée de cet algorithme récursif est la suivante : à chaque étape, on regarde si b est égale à 0. Si il est égale à 0, on renvoie la valeur 1. Sinon, on renvoie la valeur a multiplié par la valeur renvoyée par Puissance (a, b-1). Comme b diminue à chaque étape, on va nécessairement arriver au cas ou b=0 (que l'on appelle cas simple ou cas de base). Et pour parvenir à cette étape, on aura multiplié a par lui-même b fois puis par 1. Ce qui est la définition de la puissance (la puissance mathématique est naturellement récursive, comme beaucoup d'outils mathématiques).
          </para>
          <para>
            <programlisting>
              factorielle : 
              Soit FACTORIELLE (a) une fonction sur les entiers Naturels, 
              FACTORIELLE (a) = SELON a 
              a = 0 -&gt; 1 
              a -&gt; a*FACTORIELLE (a-1)
            </programlisting>
          </para>
          <para>
            Cet algorithme fonctionne comme le précédent, si ce n'est que l'on a un paramètre unique. On aura donc multiplié a par (a-1) par (a-2) par ... par 1.
          </para>
        </section>
        <section>
          <title>En Reason</title>
          <para>
            Implémentation avec Reason
          </para>          
          <para>
            <programlisting langage="reason">
/** 
 * @pow
 * Small function to calculate pow of an integer.
 * @param a int integer to get pow from
 * @param b int>0 power wanted
 * @return a^b
*/
let rec pow a b =&gt; {
    /** 
      * Equivalent to : 
      * if (b == 0) {
      *   1
      * } else {
      *     a * pow a (b - 1)
      * };
      */
    b == 0 ? 1 : a * pow a (b - 1);
};

/** 
 * @factorielle
 * Small function to calculate factorielle of an integer.
 * @param a int>0 integer to get factorielle from
 * @return !a
*/
let rec factorielle a =&gt; {
    a == 0 ? 1 : a * factorielle (a - 1);
};
            </programlisting>
          </para>
        </section>
      </section>
      <para>
        Nous venons donc de réaliser deux fonctions mathématiques simples, une fois en fonctionnel, une fois en impératif. On peut d'ores et déjà pointer quelques différences entre ces deux visions de programmation : au niveau de la preuve d'algorithmes (ici fait de façon grossière par une explication logique), l'algorithme fonctionnel n'est pas mathématiquement démontrable (il existe des méthodes de preuve pour de tels algorithmes, mais elles définissent de nouveaux axiomes) contrairement aux algorithmes fonctionnels qui sont des algorithmes mathématiques. C'est l'une des principales différences entre ces deux visions de la programmation et la raison de préférer l'un à l'autre. Si vous avez besoin d'être certains de comment et où sont stockés les éléments dans votre ordinateur, comment est utilisée la mémoire, etc., la programmation impérative est la plus adaptée. Par contre, si vous avez besoin d'être sûr que votre programme va fonctionner comme attendu et être capable de le démontrer simplement
      </para>
    </section>
    <section>
      <title>Listes</title>
      <para/>
      <para>La structure de liste est une structure mathématique naturellement récursive. En effet, une liste est un ensemble d'éléments tel que l'on ne peut accéder qu'à l'élément en tête de la liste (le dernier entré). Une liste sera donc représentée ainsi : Liste = [Tête, ...Queue] dans les algorithmes. Dans un premier temps, nous allons apprendre à manipuler ce type de structure puis nous verrons ce qu'il est possible de faire dessus.
      </para>
      <para/>
      <section>
        <title>Manipuler des listes.</title>
        <para>
          Nous avons dit que les listes étaient des structures récursives (ou inductives). Pour construire une liste, on "empile" des éléments les uns au-dessus des autres puis on les dépile. Il convient donc de manipuler principalement via des fonctions récursives. Si il est possible de recréer des listes et leurs opérateurs dans des langages impératifs (tel que C ou JAVA), ce n'est pas une façon "logique" pour stocker des éléments en impératif (on utilisera plutôt des tableaux, permettant d'accéder directement à tous les éléments). Par contre, les listes sont des structures natives en programmation fonctionnelle. La structure est dynamique et sera souvent utilisée pour stocker un ensemble d'éléments amené à être régulièrement modifié. Sinon, les tuples (que nous verrons plus tard) seront des structures plus appréciées. 
        </para>
        <para/>
        <section>
          <title>Premières armes</title>
          <para/>
          <para>
            Commençons par manipuler simplement des listes
          </para>
          <section>
            <title>Affichons tous les éléments d'une liste simple (ne contenant que des singletons)</title>
            <para>
              Voyons comment lire une liste et en afficher chaque éléments. 
            </para>
            <para>
              Tout d'abord, l'algorithme : 
              <programlisting>
                Soit L une liste. 
                Soit F une fonction de X Liste dans Vide (ou X est un type quelconque).
                F (l) = Selon l
                Vide(l) -&gt; Rien à faire ou afficher Vide selon les envies (On est arrivé au bout de liste puis ce qu'elle est vide).
                NonVide(l) -&gt; Afficher Tête(l); F (Queue (l)). (On affiche le premier élément de la liste puis on rappelle la fonction avec la suite de la liste).
              </programlisting>
            </para>
            <para>
              On se contente de prendre le premier élément que l'on trouve pour l'afficher, puis on passe à la suite. Le cas de base est vide car il n'a rien à faire.
            </para>
            <para>
              Le code en reason : 
              <programlisting langage="reason">
/**
 * @name printList
 * @ Fonction affichant les éléments d'une liste 1 à 1 a  -&gt; b  -&gt; x  -&gt; []
 * @param l string list Liste de chaînes de charactère à afficher
 * @print List element in the format E  -&gt; E  -&gt; E  -&gt; ...  -&gt; []
 */
let rec printList = fun 
    | [] =&gt; print_string "[]"
    | [t, ...q] =&gt; print_string (t ^ " -&gt; "); printList q;
            </programlisting>
            </para>
            <para>
              Cette fonction affichera tous les éléments d'une liste. C'est une fonction basique qui permet surtout de voir comment manipuler une liste. Maintenant, travaillons sur des listes.
            </para>
          </section>
          <section>
            <title>Fonctions de recherche et spécifications</title>
            <para>
              Nous allons implémenter les fonctions suivantes : recherche d'un élément e dans une liste, suppression des doublons dans une liste puis décompte du nombre d'occurrences (nombre de fois où il apparaît) d'un élément placé en paramètre. Mais tout d'abord les algorithmes :).
            </para>
            <section>
              <title>Les algorithmes</title>
              <para>
                Recherche d'un élément :

                Le concept est simple. On parcourt la liste jusqu'à ce que l'on trouve l'élément cherché. On a donc : 
                <programlisting>
                  Soit Recherche une fonction dans Booléen (Vrai ou Faux). 
                  Recherche(Élément, Liste) = Selon (Liste) 
                  Vide(Liste) -&gt; Faux 
                  NonVide(Liste) -&gt; Tête(Liste) = Éléments ou alors Recherche(Éléments, Queue(Liste)) 
                </programlisting>
              </para>
              <para>
                Suppression des doublons dans une liste : 
                Cette fois, on va parcourir la liste et, pour chaque élément, appeler la fonction de recherche. Si l'élément est encore dans la liste, on passe au suivant, sinon, on passe au suivant en ajoutant l'élément courant à la liste de retour. Ce qui donne : 
                <programlisting>
                  Soit SupDoublons une fonctions dans X Liste
                  SupDoublons(l) = Selon l 
                  Vide(l) -&gt; Vide
                  NonVide(l) -&gt; Si Recherche(Tête(l),Queue(l)) alors SupDoublons(Queue(l)) ou alors Construire Tête(l) (SupDoublons(Queue(l)))
                </programlisting>
              </para>
              <para>
                Nombre d'occurrences de E dans L :
                <programlisting>  
                  Soit NombreDe une fonction dans int (entiers)
                  NombreDe(E,L) = Selon (L) 
                  Vide(L) -&gt; 0
                  NonVide(L) -&gt; Si Tête(L)=E alors 1 + NombreDe(E,Queue(L)) sinon NombreDe(E,Queue(L))
                </programlisting>
              </para>
              <para/>
            </section>
            <para>
              Place au code.
            </para>
            <section>
              <title>Code Reason</title>
              <para>
                <programlisting langage="reason">
/**
 * @name estDans
 * @ Fonction permettant de savoir si un élement E est dans une liste L
 * @param e 'a Paramètre de type quelconque 
 * @param l 'a list List d'élément du même type que e
 * @return true si e in list, false else
 */
let rec estDans e =&gt; fun
    |[] =&gt; false
    |[t, ...q] =&gt; t == e || estDans e q;

/**
 * @name doublonsSk
 * @ Fonction retirant les doublons d'une liste
 * @param l 'a list list d'élément.
 * @return liste l sans doublons
 */
let rec doublonsSk = fun
    |[] =&gt; []
    |[t, ...q] =&gt; estDans t q ? doublonsSk q : [t, ...(doublonsSk q)];

/**
 * @name nbDe
 * @ Fonction permettant de calculer le nombre d'occurence d'un élément dans une liste
 * @param e 'a élément de type quelconque
 * @param l 'a list Liste d'élément du même type
 * @return nb d'occurence de e dans a
 */
let rec nbDe e =&gt; fun
    |[] =&gt; 0
    |[t, ...q] =&gt; t == e ? 1 + nbDe e q : nbDe e q;
                </programlisting>
              </para>
              <para>
                Vous voilà désormais armés de quelques fonctions basiques sur les listes. Vous pouvez compléter ces fonctions avec des fonctions pour inverser la liste par exemple. Et nous allons tout de suite compléter notre collection avec quelques fonctions un peu plus amusantes :)
              </para>
            </section>
          </section>
        </section>
        <section>
          <title>Les fonctions de tri, de l'élèves au maître.</title>
          <para>
            Voyons maintenant deux fonctions de tri sur les listes. La première est la fonction basique de tris. Il est déconseillé de l'utiliser, elle est particulièrement peu efficace. Nous allons également profiter de ces fonctions de tri pour voir les deux méthodologies d'implémentation pour les fonctions récursives. Jusqu'à présent, nous avons empilé les opérations dans les algorithmes et programmes au niveau de l'appel récursif. C'est ce que l'on appelle de la récursivité non terminale, car au moment de l'appel récursif, il y a encore des opérations à effectuer. L'avantage de cette façon de faire est qu'elle est logique vis-à-vis de la récursivité mathématique. L'inconvénient, c'est que cela prend vite beaucoup de place dans la mémoire de notre environnement. Aussi, pour éviter cela, une autre façon de faire, la récursivité terminale existe. Dans ce cas, l'objectif est qu'au moment de l'appel récursif, le programme n'est plus d'opérations à exécuter. Il va donc être nécessaire d'utiliser des accumulateurs. Nous allons utiliser la première fonction de tri (que l'on va appeler tri_bulles) pour illustrer cette différence.
          </para>
          <para/>
          <section>
            <title>Tri Bulle</title>
            <para/>
            <para>
              La fonction tri bulle est la fonction de tri la plus 'instinctive'. Elle se contente de regarder chaque élément puis dans les insérer dans la liste triée. 
            </para>
            <para>
              Nous allons donc avoir l'algorithme suivant en fonctionnel non terminal : 
              <programlisting>
                Soit tribulle une fonction dans listes.
                tribulle(l) = Selon l
                Vide(l) -&gt; Vide
                NonVide(l) -&gt; Faire 
                  Soit ltriée = tribulle(Queue l) dans
                  Si Tête(l) &lt; Tête(ltriée) alors Construire Tête(l) ltriée sinon Construire Tête(ltriée) tribulle(Construire Tête(l) Queue(ltriée))
              </programlisting>
              et celui-ci en récursif terminal :
              <programlisting>
                Soit tribulle une fonction dans listes.
                tribulle(l, acc) = Selon l
                Vide(l) -&gt; acc
                NonVide(l) -&gt; Faire 
                  Si Tête(l) &lt; Tête(acc) 
                  alors tribulle Queue(l) (Construire Tête(l) acc) 
                  sinon tribulle Queue(l) (tribulle (Construire Tête(l) Queue(acc)) [Tête (acc)])
              </programlisting>
            </para>
            <para>
              Nous voyons bien sûr cet exemple que les deux façons de procéder ont globalement le même fonctionnement. Ici, dans les deux cas, on compare l'élément courant à une liste déjà triée (soit l'accumulateur, soit le tri de la suite de la fonction). On voit aussi, pour cette fonction qu'il n'y a pas de gain de temps quelle que soit la solution. Une fonction en récursif terminal et une fonction en récursif non terminal auront, si elles sont bien pensées, le même temps d'exécution. Cependant, l'espace n'est clairement pas occupé de la même façon. Dans la récursivité terminale, on demande au programme de travailler avec un espace mémoire connue représenté par l'accumulateur et c'est ce paramètre que l'on fait varier à chaque étape. En non terminal, on demande à la pile d'exécution (généralement, cela va se traduire par une occupation de la RAM et de la mémoire processeur) de garder en mémoire les actions à effectuer une fois que l'on aura atteint un cas connu. Vous pourrez voir en testant les.
            </para>
            <para/>
            <para>
              Le code :
              <programlisting langage="reason">
/** 
 * Some basic sort functions
*/

/**
 * @name insert_nt
 * @ Fonction permettant d'insérent un élément dans une liste triée.
 * @param e 'a Élément du type de la liste
 * @param comp 'a -&gt;'a -&gt; bool fonction de comparaison
 * @param l 'a list Liste d'élément triée
 * @return e inséré dans l triée.
 */
let rec insert_nt e comp =&gt; fun
  |[] =&gt; [e]
  |[t, ...q]  =&gt; comp e t ? [e, t, ...q] : [t, ...insert_nt e comp q];

/**
 * @name tri_bulle_nt
 * @ Fonction permettant de trier une liste
 * @param comp 'a -&gt; 'a -&gt; bool fonction de comparaison
 * @param l 'a list Liste d'élément
 * @return l trié
 */
let rec tri_bulle_nt comp =&gt; fun
  |[] =&gt; []
  |[t, ...q]  =&gt; insert_nt t comp (tri_bulle_nt comp q);

/**
 * @name insert
 * @ Fonction permettant d'insérent un élément dans une liste triée.
 * @param e 'a Élément du type de la liste
 * @param acc 'a list Accumulateur. '
 * @param comp 'a -&gt; 'a -&gt; bool fonction de comparaison
 * @param l 'a list Liste d'élément triée
 * @return e inséré dans l triée.
*/
let rec insert e acc comp =&gt; fun
  |[] =&gt; List.append acc [e]
  |[t, ...q]  =&gt; comp e t ? List.append acc [e, t, ...q] : insert e q comp (List.append acc [t]);
/**
 * @name tri_bulle
 * @ Fonction permettant de trier une liste
 * @param l 'a list Liste d'élément
 * @param acc 'a list Accumulateur. '
 * @param comp 'a -&gt; 'a -&gt; bool fonction de comparaison
 * @return l trié
*/
let rec tri_bulle acc comp =&gt; fun
  |[] =&gt; acc
  |[t, ...q]  =&gt; tri_bulle q comp (insert t acc comp []);
              </programlisting>
            </para>
            <para>
              Pour le code, nous avons décomposé la partie terminale en deux fonctions pour plus de clarté. Aussi, la sous fonction insert est une fonction capable d'ajouter un élément dans une liste déjà triée. On peut aussi voir que l'on a travaillé sur des listes quelconques en passant en argument une fonction de comparaison comp. Ainsi, ces fonctions permettent de trier les listes par ordre croissant ou décroissant, quel que soit le type de donnée dans la liste (et à condition qu'il existe une fonction de comparaison d'ordre).
            </para>
            <para/>
          </section>
          <section>
            <title>Tri Fusion</title>
            <para/>
            <para>
              Tout d'abord, présentons le principe de cette fonction.
            </para>
            <para>
              La fonction de tri fusion (appelé quick_sort en anglais) est la fonction de tri optimale, à l'heure actuelle, quand on fait face à un ensemble quelconque de données (exemple général : une liste d'entiers aléatoire). Cette fonction sur la méthode dite 'diviser pour régner' consistant à 'découper' un grand problème en plusieurs sous-tâches que l'on sait effectuer. Ici, notre problème est : ayant une liste quelconque d'éléments, j'aimerais être capable de la trier dans un certain ordre. Ce que je sais assurément faire : fusionner des listes triées pour obtenir une liste triée (il suffit de comparer les éléments un à un), diviser une liste deux (je prends les deux premiers éléments et les mets chacun dans une liste), compter le nombre d'éléments, etc. ... Savoir compter le nombre d'éléments de la liste ne nous aidera pas à la trier. Par contre, sachant couper une liste en 2, je sais transformer une liste en un ensemble de singletons et je sais trier un singleton (c'est un élément seul donc il est naturellement trié). Donc si je coupe ma liste jusqu'à n'avoir que des singletons, j'obtiens plein de petites listes triées. Ensuite, j'ai dit que je savais fusionner deux listes triées de sorte que la liste obtenue soit triée. Donc, il ne me reste qu'à fusionner toutes les listes triées deux à deux, puis fusionné les listes obtenues, etc., etc., jusqu'à n'avoir plus qu'une liste contenant tous les éléments d'origine, mais trié.
            </para>
            <para/>
            <para>
              Nous sommes donc face à un processus qui effectue deux actions : l'une consiste à découper la liste, l'autre à fusionner les listes obtenues une fois celles-ci triées. Je vous propose donc de faire trois fonctions, en récursivité terminale, pour résoudre notre problème. Une fonction DIVISE, qui coupe la liste en deux, une fonction FUSIONNE qui prend deux listes triées et renvoie une seule liste triée, et la fonction qui nous intéresse TRI_FUSION qui va prendre une liste et effectuer dessus les opérations de fusion et de division jusqu'à avoir le résultat attendu.
            </para>
            <para/>
            <para>
              Ce qui donne l'algorithme : 
            </para>
            <programlisting>
              Soit DIVISE une fonction dans (liste,liste).
              DIVISE(l,acc1,acc2) = Selon l
              Vide(l) -&gt; (acc1,acc2)
              Vide(Queue(l)) -&gt; (Construire 1 acc1, acc2)
              NonVide(l) -&gt; DIVISE Queue(Queue(l)) (Construire Tête(l) acc1) (Construire Tête(Queue(l)) acc2)

              Soit FUSIONNE un fonction dans liste.
              FUSIONNE(l1,l2,acc, comparateur) = Selon l1, l2
              Vide(l1) -&gt; Construire l2 acc
              Vide (l2) -&gt; Contruire l1 acc
              NonVide(l1) et NonVide(l2) -&gt; Si hd(l1) comparateur hd(l2) alors FUSIONNE(Queue(l1),l2, Construire acc l1) sinon FUSIONNE(l1,Queue(l2), Construire acc l2)

              La fonction comparateur est une fonction de X dans Booléen. 

              Soit TRI_FUSION (l,acc, comparateur) = selon l
              Vide(l) -&gt; []
              NonVide(l) -&gt; Soit (l1,l2)=DIVISE(l,[],[]) dans
                FUSIONNE (TRI_FUSION l1 [] comparateur) (TRI_FUSION l2 [] comparateur) [] comparateur
            </programlisting>
            <para/>
            <para>
              Cet ensemble est un peu plus complexe à écrire et retenir que le tri bulle, mais il est beaucoup plus efficace. Et, finalement, les trois fonctions réalisées sont vraiment simples à comprendre et à réaliser. Cependant, on peut remarquer que la partie TRI_FUSION n'est pas sous forme terminale. En effet, lors du dernier appel, une opération de fusion est mise en attente pendant que l'on trie les listes divisées. Je n'ai pas de solution terminale à vous proposer actuellement. Si quelqu'un a une solution à proposer, j'en serai ravie.
            </para>
            <para/>
            <para>
              Côté code maintenant : 
            </para>
            <programlisting langage="Reason">
             /**
 * @name divise
 * @ Fonction permettant de diviser une liste
 * @param l 'a list Liste d'élément
 * @return ('a list, 'a list) liste l divisée en 2.
 */
let rec divise a1 a2 =&gt; fun
  |[]  =&gt; (a1, a2)
  |[t, ...[]]  =&gt; ([t, ...a1], a2)
  |[t1,t2, ...q]  =&gt; divise [t1, ...a1] [t2, ...a2] q;
/**
 * @name fusion
 * @ Fonction permettant de fusionner une liste
 * @param comp 'a -&gt;'a -&gt;bool fonction de comparaison
 * @param l1 'a list Liste d'élément triée selon comp
 * @param l2 'a list Liste d'élément triée selon comp
 * @return 'a list Liste l1 &amp;&amp; l2 fusionnée et triée selon comp'
*/
let rec fusion acc comp =&gt; fun
  |([], l2)  =&gt; List.append acc l2
  |(l1 ,[])  =&gt; List.append acc l1
  |([t1, ...q1], [t2, ...q2])  =&gt; comp t1 t2 ? fusion(List.append acc [t1]) comp  (q1,[t2, ...q2]) : fusion (List.append acc [t2]) comp  ([t1, ...q1],q2);
/**
 * @name order
 * @ Fonction permettant de trier une liste
 * @param comp 'a -&gt;'a -&gt;bool fonction de comparaison
 * @param l 'a list Liste d'élément
 * @return l trié
*/
let rec order comp =&gt; fun
  |[]  =&gt; []
  |[t, ...[]]  =&gt; [t]
  |l  =&gt; {
    let (l1,l2) = divise [] [] l; 
    fusion [] comp ((order comp l1), (order comp l2))
  };
            </programlisting>
          </section>
        </section>
      </section>
      <para/>
      <para>
        Cela termine notre présentation des listes, structures centrales de la programmation fonctionnelle. Nous allons maintenant nous atteler à la résolution de problèmes récursifs.
      </para>
    </section>
    <section>
      <title>Des problèmes</title>
      <para/>
      <para>
        <quote>A tous les problèmes une solution, si pas de solution, pas de problème., Sur deux tons, Maxime le Forestier</quote>
      </para>
      <para>
        Attaquons-nous donc à de petits problèmes dont les solutions sont déjà connues et démontrées. Nous allons implémenter les fonctions de résolution de deux problèmes naturellement récursifs. La suite de Fibonacci puis le problème des tours de Hanoi. Les deux problèmes sont énoncés, respectivement, en ces termes : avoir une fonction permettant d'obtenir la valeur de la suite de Fibonacci au rang n (donné en argument), avoir une fonction me permettant d'obtenir tous les mouvements nécessaires à la résolution du problème des tours de Hanoi pour n éléments (donné en argument). Je vous invite à réfléchir par vous-même à ces problèmes si vous en avez le courage avant d'en lire la résolution.
      </para>
      <para/>
      <section>
        <title>Fibonacci, la suite.</title>
        <para/>
        <para>
          Commençons par un petit rappel.
        </para>
        <para/>
        <para>
          Qu'est ce que la suite de Fibonacci ? 
        </para>
        <para/>
        <para>
          Cette suite fut découverte par un mathématicien italien cherchant à modéliser l'évolution d'une population de lapins. Pour plus d'informations sur l'histoire de cette suite et les liens entre elle et d'autres concepts mathématiques (comme le nombre d'or), je vous invite à consulter cet article <ulink href="http://images.math.cnrs.fr/Mysteres-arithmetiques-de-la-suite-de-Fibonacci.html">http://images.math.cnrs.fr/Mysteres-arithmetiques-de-la-suite-de-Fibonacci.html</ulink>et/ou, la vidéo suivante <ulink href="https://www.youtube.com/watch?v=DxmFbdp7v9Q">http://images.math.cnrs.fr/Mysteres-arithmetiques-de-la-suite-de-Fibonacci.html</ulink> par micmaths. Pour ce que nous allons faire, il suffit de savoir comment se construit la suite. Cette suite est une structure définie récursivement de la façon suivante : le terme n+1 de la suite se calcule en faisant la somme des deux termes précédents. Ce qui donne fibonacci(n+1)= fibonacci(n) + fibonacci(n-1). Et comme il faut commencer quelque part, les termes 0 et 1 sont égaux respectivement à 0 et 1. On a donc : fibonacci(0)=0, fibonacci(1)=1, pour tout n > 1 fibonacci(n+1)=fibonacci(n)+fibonacci(n-1).
        </para>
        <para/>
        <para>
          Implémentation : 
          <programlisting langage="reason">
/**
 * @name fibo
 * Fonction that will calculate the Nth term of fibonnacci serie.
 * @param n int Range where you want to calculate
 * @return finbonnacci value @ Nth poosition
 */
let rec fibo n =&gt; {
  n == 0 ? 0 : (n == 1 ? 1 : fibo (n-1) + fibo (n-2))
};
          </programlisting>
        </para>
        <para/>
        <para>
          Et voila une toute petite fonction pour calculer de très grand nombre ;). Passons à un problème un peu plus tendu. 
        </para>
      </section>
      <section>
        <title>Les tours ... de Hanoï</title>
        <para/>
        <para>
          Pour ceux qui ne connaîtraient pas les tours de Hanoï, il s'agit d'un casse-tête français, imaginé par un mathématicien. Il consiste en un support sur lequel sont disposés trois pics. Une tour de disques (de taille croissante) et placé sur l'un des pics extrêmes et le but est  de déplacer la tour sur le pic opposée sachant que l'on ne peut bouger qu'un disque à la fois et qu'un disque ne peut se placer qu'au-dessus d'un disque plus petit. Vous pouvez y jouer ici <ulink href="http://matoumatheux.ac-rennes.fr/tous/enigme/tour0.htm">http://matoumatheux.ac-rennes.fr/tous/enigme/tour0.htm</ulink> et en apprendre plus sur wikipédia. 
        </para>
        <para/>
        <para>
          Encore une fois, ce problème est naturellement récursif. Une suite d'action répétée permet de résoudre le problème. La question est quelle suite d'actions. Et pour cela, il nous faut trouver deux choses : les cas simples (les situations dans lesquelles je sais ce qu'il faut faire), et la condition de récurrence (étant dans la situation N comment puis-je me rapprocher de mes cas simples S). Ici, je sais comment résoudre le problème si je n'ai pas de disque à déplacer (je n'ai alors rien fait), si je n'ai qu'un seul disque (je n'ai qu'à l'amener à l'arrivée), et quand je n'ai plus que deux disques (il faut que je déplace le premier disque sur la part intermédiaire, puis le second sur l'arrivée puis redéplacer le plus petit de l'intermédiaire vers l'arrivée). Ensuite, si je veux résoudre pour le problème pour trois disques, je connais la méthode : déplacer le plus petit sur l'arrivée (cas à un disque), puis déplacer le disque moyen sur le disque intermédiaire (début cas à deux éléments).
          <itemizedlist>
            Déplacer N disques de D vers A en passant par I revient à: 
            <listitem>
              Déplacer N-1 disques de D vers I en passant par A
            </listitem> 
            <listitem>
              Déplacer 1 disques de D vers A
            </listitem>
            <listitem>
              Déplacer N-1 disques de I vers A en passant par D
            </listitem>
          </itemizedlist>
        </para>
        <para/>
        <para>
          Implémentons : 
          <programlisting langage="Reason">
/**
 * @name hanoi
 * fonction affichant la combinaison d'étape à faire pour résoudre le problème.
 * @param n int nombre de disque 
 * @para d string pique de départ
 * @para a string pique intermédiaire
 * @para i string pique d'arrivée $
*/
let rec hanoi n d a i =&gt;
  n == 0 ? "" : (n == 1 ? d ^ a : (hanoi (n-1) d i a) ^ "- " ^ (hanoi 1 d a i) ^ " - " ^ (hanoi (n-1) i a d));
            </programlisting>
        </para>
        <para>
          Cette fonction affichera bien les étapes nécessaires à la résolution du problème et ces étapes seront optimales (impossible d'en faire moins). Je vous renvoie à Wikipédia pour les démonstrations si vous êtes dubitatifs :). Attention cependant lors de la création de cette fonction à l'ordre des paramètres si vous voulez avoir l'affichage correctement ;).
        </para>
        <para/>
        <para>
          Je ne vous proposerai pas de problème plus complexe dans cet article, mais vous pourrez toujours trouver des problèmes amusants à résoudre dans les énigmes impliquant des déplacements. Encore une fois, comme on a pu le voir dans ces deux problèmes, le plus difficile n'est pas de créer le code, mais bien de trouver comment résoudre le problème.
        </para>
      </section>
    </section>
  </section>
  <para/>
  <para>Voici donc pour cet article. J'espère que vous aurez appris de nouvelles choses :). Je vous laisse les liens vers les sources utilisées pour faire cet article et mon répertoire git où vous pourrez retrouver tous les fichiers de codes présentés ici.
  </para>
  <para>
    <itemizedlist>
      <listitem>
         <ulink href = "https://facebook.github.io/reason/tools.html">Reason, page officielle</ulink>
      </listitem>
      <listitem>
        <ulink href = "https://fr.wikipedia.org/wiki/Programmation_fonctionnelle">La programmation fonctionnelle, version wikipédia</ulink>
      </listitem>
      <listitem>
        <ulink href = "http://deptinfo.unice.fr/~roy/progfonc.html">La programmation fonctionnelle, version Paul Graham</ulink>
      </listitem>
      <listitem>
        <ulink href = "https://github.com/titouanfreville/reasonmldiscovery">Les codes de l'article</ulink>
      </listitem>
    </itemizedlist>
  </para>
  <para>
    Vous remarquerez sans doute que je n'aie pas relevé toutes les références citées, mais seulement celle qui me semble indispensable pour suivre cet article.
  </para>
</section>
