<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<section>
  <title>Créer des applications avec Bash et GetOpt</title>
  <para/>
  <section>
    <title>Introduction</title>

    <para/>

    <para>
      Vous aimez les terminaux bash ? Vous aimez automatiser toutes vos tâches récurrentes et voudriez les partager avec d'autres ? Ou tout simplement, vous voulez créer une mini-application en bash ? Cet article est fait pour vous. Il vous expliquera comment créer des applications bash simple avec options commande et arguments. Comme un vrai programme quoi.
    </para>
    <para/>

    <para>
      Dans un premier temps, je vais fixer quelque pré-requis pour cet article. Je vous invite également à travailler depuis un environnement Linux avec bash d'installer, et d'ajouter un répertoire `~/bin` ou autre à votre path (`export PATH=$PATH:=REPO_TO_WORKING_SCRIPT`).
    </para>

    <para/>
  </section>
  <section>
    <title>Pré-requis</title>
    <para/>
    <para>
      A titre personnel, j'ai utilisé et créer des programmes bash utilisant getopt uniquement pour des terminaux Mac et Linux. Je ne suis pas sûr de son support par le shell Windows.
    </para>
    <section>
      <title>Pré-requis Linux</title>
      <para>
        Il n'y a pas vraiment de pré-requis sous les systèmes Linux. Théoriquement, getopt devrait être installé par défaut. Je vous recommande tout de même de vérifier sa présence avec un `getopt --version`. Si il n'est pas installé, faite-le. Je vous recommande également de créer un répertoire bin dans votre dossier local et d'éditer votre fichier `.bashrc` pour ajouter au path le répertoire bin et pouvoir l'oublier. Ensuite, pensez à placer tous vos scripts bash dans ce répertoire et à les rendre exécutables. Ceci vous permettra de ne pas avoir à préciser la localisation du fichier pour l'exécuter.
      </para>
    </section>
    <section>
      <title>Pré-requis MacOS</title>
      <para>
        Sous mac, il est impératif d'installer gnu-getopt si vous voulez pouvoir supporter l'utilisation d'argument long. Si vous ne voulez pas ajouter cette dépendance à vos programmes, n'utilisez que les arguments courts devrait vous permettre d'utiliser le getopt natif. Encore une fois, quelle que soit la solution choisie, vérifier les installations. Et encore une fois, vous pouvez ajouter un répertoire à votre PATH pour simplifier l'exécution de vos scrips.
      </para>
    </section>
    <para></para>
    <para>Je n'ai pas de recommandations spécifiques au sujet des éditeurs de textes, assurez-vous seulement que celui que vous préférez supporte la coloration syntaxique pour bash. Personnellement, j'utilise sublimetext ou atome.</para>
    <para></para>
    <para>
      Je vais vous guider à travers différentes étapes :
      <itemizedlist>
        <listitem>
          Premier pas : Les bases de bash.
        </listitem>
        <listitem>
          GetOpt : le concept et les bases
        </listitem>
        <listitem>
          Fonctionnalités avancées et création d'un programme simple.
        </listitem>
      </itemizedlist>
    </para>
    <para/>
  </section>
  <section>
    <title>Découvrons bash</title>
    <para/>
    <section>
      <title>A petits pas</title>
      <para/>
      <para>
        Tout d'abord, il faut rappeler que la programmation en bash est une programmation de type impérative. Nous savons donc ce que la machine fait, mais pas comment ;). Nous retrouvons bien évidemment toutes les structures classiques de la programmation impérative, à savoir les boucles, la création de fonctions et la création de variables. Cependant, bash est avant tout un langage de scripting, c'est-à-dire que son objectif principal est de lancer d'autre programme permettant de réaliser quelque chose. Si il est possible de réaliser des opérations mathématiques simples, le processus est tout de même assez lourd. Cependant, savoir réaliser ce type d'opération peut s'avérer plus qu'utiles. Ainsi, l'objectif de cette première partie sera de créer un menu simple permettant de lancer une calculatrice ou l'écriture d'une citation quelconque.
      </para>
      <para></para>
      <section>
        <title>Pré-requis de la partie</title>
        <para />
        <para>
          <itemizedlist>
            <listitem>Un environnement disposant d'un terminal bash (sous Mac : ouvrir le terminal puis entrer la commande bash).</listitem>
            <listitem>Installer fortune et figlet (figlet permet de styler les outputs bash et fortune et un générateur de citations). A défaut, nous verrons comment créer une "base" de citation</listitem>
          </itemizedlist>
        </para>
      </section>
      <section>
        <title>Le concept</title>
        <para/>
        <para>
          Nous allons donc d'abord faire un "petit" script bash avec menu. Comme dit précédemment, ce script à pour but de laisser le choix à l'utilisateur entre faire un calcul ou voir une citation. Ce script va donc être composé de trois parties. La première partie, la plus simple, est celle du générateur de citation. En effet, on utilise pour cela le paquet fortune déjà existant. La deuxième est la partie menu car plus facile à réaliser dans le cadre d'un script bash. Enfin, viendra la partie calcul. Pour chaque partie, nous détaillerons le fonctionnement de la fonction afin de vous initier au langage. Si vous êtes déjà familier avec bash, vous pouvez passer directement à l'introduction de getopt.
        </para>
      </section>
      <section>
        <title>Afficher une citation</title>
        <para/>
        <para>
          Créons donc notre première fonction. Tout d'abord, nous allons créer un fichier bash appelé `simple_menu.sh` par exemple. La première de ce menu doit contenir l'instruction <programlisting langage="bash">#!/bin/bash</programlisting> ou <programlisting langage="bash"> #!/env/bash </programlisting>. Tous deux demandant à ce que le script soit utilisé en bash. Si vous ne précisez pas ce commentaire et que vous êtes dans un autre système de shell (eg: la console mac), le script pourrait rencontrer des erreurs. Ensuite, nous allons créer la fonctionnalité de génération de citations. Pour cela, nous allons simplement ajouter <programlisting langage="bash">figlet $(fortune)"</programlisting>. Ce qui nous donnera le fichier suivant :
          <programlisting language="bash">
            #!/bin/bash
            figlet "$(fortune"
          </programlisting>
          Vous pouvez exécuter ce programme, ce qui devrait vous donner quelque chose comme :
          <mediaobject>
            <imageobject>
              <imagedata fileref='http://freville.iiens.net/images/filget_output.png' />
            </imageobject>
          </mediaobject>
        </para>
        <para/>
        <para>
          Ce qui se passe :<br/>
          Lors de l'appel au script, votre script va se lancer dans un environnement bash (étapes non visibles). Ensuite, il va arriver sur la commande figlet. Figlet est une commande prenant un texte en argument et renvoyant ce même texte mais avec une stylisation particulière. Ici, le texte est représenté par "$(fortune)". Ce "$(fortune)" est une fonction. Les " " sont obligatoires afin de considérer ce qu'il y a à l'intérieur de celle ci comme étant une seule entité. Ensuite, le $( XXXX ) représente ce qui est renvoyé par la fonction XXXX (ici fortune). Nous demandons donc de passer à figlet le retour de la fonction fortune. Fortune est une fonction bash qui renvoie une citation quelconque.
        </para>
        <para>
          Maintenant, que faire si l'utilisateur ne dispose pas de figlet et/ou fortune (ce qui est probablement le cas car ce ne sont pas des utilitaires basiques). Nous devrions les remplacer par notre propre "système". Pour cela, il nous faut d'abord savoir si les programmes existent. Pour cela, nous allons utiliser le fait que la plupart des programmes bash ont un argument -v permettant de connaître la version installée du programme. Cette fonction va afficher la version actuelle du programme demandé si celui existe (et renvoyer un code 0), sinon, une erreur et un code retour non nulle. Nous allons donc tester l'existence des programmes ainsi :
          <programlisting language="bash">
            figlet -v &gt; /dev/null 2&gt; /dev/null &amp;&amp; FIGLET_INSTALLED=0 || FIGLET_INSTALLED=1
            fortune -v &gt; /dev/null 2&gt; /dev/null &amp;&amp; FORTUNE_INSTALLED=0 || FORTUNE_INSTALLED=1
          </programlisting>
          Ici, nous appelons l'option -v des programmes figlet puis fortune. Afin d'éviter de voir lors de l'exécution du programme la sortie de ces fonctions ou leurs erreurs (qui ne nous intéressent pas ici), nous demandons à ce qu'elles soient re-dirigées vers /dev/null (le trou noir de bash). Pour cela, nous utilisons l'opérateur &gt; qui dirige la sortie demandée à gauche vers l'argument placer à droite. Appeler sans chiffre, il re-dirige la sortie global du programme, mais il reste l'affichage des erreurs systèmes (quand le programme n'existe pas) qui sont sur la sortie d'erreur standard. Cette sortie est numérotée 2. 2&gt; /dev/null redirige donc la sortie standard d'erreur, pendant la durée de la fonction, vers notre trou noir. Ensuite, si la fonction réussit, nous stockons la valeur 0 dans la variable FIGLET_INSTALLED, 1 sinon. Et nous avons récupéré l'information qui nous intéressait (la présence ou non des programmes figlet et fortune).
        </para>
        <para/>
        <para>
          Reste à utiliser ce résultat. Nous allons donc dire que si c'est programme sont installés, nous réutilisons le code de tout à l'heure. Et sinon, que fait-on ?
        </para>
        <para/>
        <para>
          Dans le cas ou figlet est manquant, il peut être remplacé par la fonction echo, fonction basique de bash pour renvoyer quelque chose dans la sortie standard. Si fortune est manquant, il nous faut trouver une solution pour obtenir des citations aléatoire.
        </para>
        <para/>
        <para>
          Implémentons donc notre "générateur" de citation. Pour cela, nous allons utiliser la fonction $RANDOM de bash dont nous allons stocker le résultat dans une variable. Puis faire un case sur la valeur de cette variable et dans certains cas, mettre une citation particulière. Ce qui va donner :
          <programlisting langage="bash">
            get_citation () {
              citation_indice=$((RANDOM%4))
              case $citation_indice in
                0) echo "Noob, je suis un noob. Un no-life un vrai. Je joue au MMORPG";;
                1) echo "42";;
                2) echo "Si l'école sa rendait les hommes libres et égaux, le gouvernement déciderait que c'est pas bon pour les marmots.";;
                *) echo "Insérer citation ici";;
              esac
            }
          </programlisting>
          Nous voici donc avec une fonction bash appelée get_citation, renvoyant une citation aléatoire. Un fortune en moins complet en fait ;). Si vous désirez pouvoir mettre plus de citation, il vous faudra modifier la valeur du modulo (%) pour autre chose que 4. Le bloc case VALEUR in ... esac permet d'attribuer à des valeurs de VALEUR une action. L'utilisation des ;; est obligatoire pour signifier la fin d'un cas.
        </para>
        <para/>
        <para>
          Maintenant que nous avons nos fonctions de remplacement, utilisons les et modifions notre simple_menu.sh pour ajouter ces dernières fonctionnalités.
          <programlisting langage="bash">
            #!/bin/bash

            get_citation () {
              citation_indice=$((RANDOM%4))
              case $citation_indice in
                0) echo "Noob, je suis un noob. Un no-life un vrai. Je joue au MMORPG";;
                1) echo "42";;
                2) echo "Si l'école sa rendait les hommes libres et égaux, le gouvernement déciderait que c'est pas bon pour les marmots.";;
                *) echo "Insérer citation ici";;
              esac
            }

            figlet -v &gt; /dev/null 2&gt; /dev/null &amp;&amp; FIGLET_INSTALLED=0 || FIGLET_INSTALLED=1
            fortune -v &gt; /dev/null 2&gt; /dev/null &amp;&amp; FORTUNE_INSTALLED=0 || FORTUNE_INSTALLED=1

            if [[ $FORTUNE_INSTALLED -eq 0 ]]
              then CITATION="$(fortune)"
              else CITATION="$(get_citation)"
            fi

            [ $FIGLET_INSTALLED -eq 0 ] &amp;&amp;  figlet -nt "$CITATION" || echo "$CITATION"
          </programlisting>
        </para>
        <para/>
        <para>
          Et maintenant, tout en fonction ;)
          <programlisting langage="bash">
            #!/bin/bash

              get_citation () {
                citation_indice=$((RANDOM%4))
                case $citation_indice in
                  0) echo "Noob, je suis un noob. Un no-life un vrai. Je joue au MMORPG";;
                  1) echo "42";;
                  2) echo "Si l'école sa rendait les hommes libres et égaux, le gouvernement déciderait que c'est pas bon pour les marmots.";;
                  *) echo "Insérer citation ici";;
                esac
              }

              print_citation () {
                figlet -v &gt; /dev/null 2&gt; /dev/null &amp;&amp; FIGLET_INSTALLED=0 || FIGLET_INSTALLED=1
                fortune -v &gt; /dev/null 2&gt; /dev/null &amp;&amp; FORTUNE_INSTALLED=0 || FORTUNE_INSTALLED=1

                if [[ $FORTUNE_INSTALLED -eq 0 ]]
                  then CITATION="$(fortune)"
                  else CITATION="$(get_citation)"
                fi

                [ $FIGLET_INSTALLED -eq 0 ] &amp;&amp; figlet -nt "$CITATION" || echo "$CITATION"
              }

              print_citation
          </programlisting>
          Oui, cela revient juste à déplacer le code qui était hors de la fonction dans une fonction puis à l'appeler pour pouvoir tester bien sûr :).
        </para>
        <para/>
      </section>
      <para>
        Maintenant que nous avons nos citations, invitons un utilisateur à les essayer :)
      </para>
      <section>
        <title>Le Menu</title>
        <para/>
        <para>
          Donc, pour le menu, nous allons avoir besoin de poser une question à l'utilisateur puis obtenir une réponse. Pour ce faire, il va nous suffire d'afficher la question puis d'attendre la réponse de l'utilisateur.
        </para>
        <para/>
        <para>
          Nous allons donc avoir le code :
          <programlisting langage="bash">
            #!/bin/bash

            get_citation () {
              local citation_indice=$((RANDOM%4))
              case $citation_indice in
                0) echo "Noob, je suis un noob. Un no-life un vrai. Je joue au MMORPG";;
                1) echo "42";;
                2) echo "Si l'école sa rendait les hommes libres et égaux, le gouvernement déciderait que c'est pas bon pour les marmots.";;
                *) echo "Insérer citation ici";;
              esac
            }

            print_citation () {
              figlet -v $gt; /dev/null 2$gt; /dev/null &amp;&amp; FIGLET_INSTALLED=0 || FIGLET_INSTALLED=1
              fortun -v $gt; /dev/null 2$gt; /dev/null &amp;&amp; FORTUNE_INSTALLED=0 || FORTUNE_INSTALLED=1

              if [[ $FORTUNE_INSTALLED -eq 0 ]]
                then CITATION="$(fortune)"
                else CITATION="$(get_citation)"
              fi

              [ $FIGLET_INSTALLED -eq 0 ] &amp;&amp; figlet -nt "$CITATION" || echo "$CITATION"
            }

            menu () {
              local action_choice="1 - Calculer quelque chose ?
            2 - Etre éclairer par la sagesse de tes ancêtres ?
            3 - Epingle Jésus à sa croix ?"
              local question="Bonjour, jeune scarabée. Dieu te parle et te propose de trouver la voie. As-tu besoin de"
              local not_an_option="Désolé, mais je n'ai pas compris le sens profond de ton interrogation ? Veux-tu ?"
              clean=${1:-0}
              [ $clean -eq 0 ] &amp;&amp; echo "$question" || echo "$not_an_option"
              echo "$action_choice"
              read -r -n 1 -p "" reponse
              echo
              case "$reponse" in
                "1") echo "Calculer n'est pas encore à ta portée. ";;
                "2") print_citation;;
                "3") exit 1;;
                *) return 2;;
              esac
            }

            menu
          </programlisting>
        </para>
        <para/>
        <para>
          Nous voila donc capable d'écouter notre utilisateur. Celui-ci peut donc demander à faire un calcul, afficher une citation, quitter le programme (exit 1) ou dire qu'il n'a pas compris la demande (return 2). La différence entre exit et return va nous être utile maintenant, puisque nous allons intégrer ce menu à une boucle d’interaction. Une telle boucle est souvent définie avec un while true, ce qui nous pose la question de comment en sortir. J'ai donc deux cas de sortie forcées de ma fonction menu : exit 1 ou return 2. Le exit 1 va permettre de couper la boucle car nous demandons à bash d'arrêter l'exécution du script. Le return 2 va nous permettre de récupérer un code de sortie non nul sans quitter la boucle. Ceci va nous permettre de pouvoir donner en argument à l'appel de menu un paramètre permettant de savoir si il doit afficher le message sans erreur ou le message d'erreur.
        </para>
        <para/>
        <para>
          Avec la boucle d'interaction, nous aurons :
          <programlisting language="bash">
            #!/bin/bash

            get_citation () {
              local citation_indice=$((RANDOM%4))
              case $citation_indice in
                0) echo "Noob, je suis un noob. Un no-life un vrai. Je joue au MMORPG";;
                1) echo "42";;
                2) echo "Si l'école sa rendait les hommes libres et égaux, le gouvernement déciderait que c'est pas bon pour les marmots.";;
                *) echo "Insérer citation ici";;
              esac
            }

            print_citation () {
              figlet -v &gt; /dev/null 2&gt; /dev/null &amp;&amp; FIGLET_INSTALLED=0 || FIGLET_INSTALLED=1
              fortun -v &gt; /dev/null 2&gt; /dev/null &amp;&amp; FORTUNE_INSTALLED=0 || FORTUNE_INSTALLED=1

              if [[ $FORTUNE_INSTALLED -eq 0 ]]
                then CITATION="$(fortune)"
                else CITATION="$(get_citation)"
              fi

              [ $FIGLET_INSTALLED -eq 0 ] &amp;&amp; figlet -nt "$CITATION" || echo "$CITATION"
            }

            menu () {
              local action_choice="1 - Calculer quelque chose ?
            2 - Etre éclairer par la sagesse de tes ancêtres ?
            3 - Epingle Jésus à sa croix ?"
              local question="Bonjour, jeune scarabée. Dieu te parle et te propose de trouver la voie. As-tu besoin de"
              local not_an_option="Désolé, mais je n'ai pas compris le sens profond de ton interrogation ? Veux-tu ?"
              clean=${1:-0}
              [ $clean -eq 0 ] &amp;&amp; echo "$question" || echo "$not_an_option"
              echo "$action_choice"
              read -r -n 1 -p "" reponse
              echo
              case "$reponse" in
                "1") echo "Calculer n'est pas encore à ta portée. ";;
                "2") print_citation;;
                "3") exit 1;;
                *) return 2;;
              esac
            }

            while true
            do
              clean=${clean:-0}
              echo
              menu $clean
              clean=$?
              echo
            done
          </programlisting>
        </para>
        <para/>
        <para>
          Voici donc un petit soft simple déjà. Mais il lui manque encore une légère fonctionnalité... La calculette :)
        </para>
      </section>
      <section>
        <title>La calculette</title>
        <para/>
        <para>
          Pour la calculatrice, nous avons plusieurs options. Soit nous récupérons l'entrée utilisateur pour la passer en calcul. Soit nous demandons à l'utilisateur l'opération qu'il veut effectuer puis les opérandes nécessaires. Nous allons choisir la plus simple, à savoir injecter l'entrée utilisateur dans une option de calcul.
        </para>
        <para/>
        <para>
          En bash, pour pouvoir effectuer un calcul, il nous faut l'appeler ainsi : $[CALCUL]. Ainsi, pour effectuer l'opération 1+1, il nous faut écrire $[1+1]. Il est possible de mettre n'importe quelle chaîne d'opération standard, la priorité est respectée. Ainsi, notre fonction de calcul sera simplement
          <programlisting language="bash">
            calcul () {
              read -r -p 'Entrez votre calcul : ' response
              echo $[$response]
            }
          </programlisting>
          Et oui, c'est la fonction la plus simple en fait :p
        </para>
        <para/>
        <para>
          Le mini-soft complet donne donc :
          <programlisting language="bash">
            #!/bin/bash

            get_citation () {
              local citation_indice=$((RANDOM%4))
              case $citation_indice in
                0) echo "Noob, je suis un noob. Un no-life un vrai. Je joue au MMORPG";;
                1) echo "42";;
                2) echo "Si l'école sa rendait les hommes libres et égaux, le gouvernement déciderait que c'est pas bon pour les marmots.";;
                *) echo "Insérer citation ici";;
              esac
            }

            print_citation () {
              figlet -v &gt; /dev/null 2&gt; /dev/null &amp;&amp; FIGLET_INSTALLED=0 || FIGLET_INSTALLED=1
              fortun -v &gt; /dev/null 2&gt; /dev/null &amp;&amp; FORTUNE_INSTALLED=0 || FORTUNE_INSTALLED=1

              if [[ $FORTUNE_INSTALLED -eq 0 ]]
                then CITATION="$(fortune)"
                else CITATION="$(get_citation)"
              fi

              [ $FIGLET_INSTALLED -eq 0 ] &amp;&amp; figlet -nt "$CITATION" || echo "$CITATION"
            }

            calcul () {
              read -r -p 'Entrez votre calcul : ' response
              echo $[$response]
            }

            menu () {
              local action_choice="1 - Calculer quelque chose ?
            2 - Etre éclairer par la sagesse de tes ancêtres ?
            3 - Epingle Jésus à sa croix ?"
              local question="Bonjour, jeune scarabée. Dieu te parle et te propose de trouver la voie. As-tu besoin de"
              local not_an_option="Désolé, mais je n'ai pas compris le sens profond de ton interrogation ? Veux-tu ?"
              clean=${1:-0}
              [ $clean -eq 0 ] &amp;&amp; echo "$question" || echo "$not_an_option"
              echo "$action_choice"
              read -r -n 1 -p "" reponse
              echo
              case $reponse in
                1) calcul;;
                2) print_citation;;
                3) exit 1;;
                *) return 2;;
              esac
            }

            while true
            do
              clean=${clean:-0}
              echo
              menu $clean
              clean=$?
              echo
            done
          </programlisting>
        </para>
      </section>
    </section>
  </section>
  <para/>
  <para>
    Maintenant que nous savons créer des programmes bash, voyons comment permettre à l'utilisateur de customiser les appels aux fonctions. Si vous avez déjà utilisé un programme en ligne de commande, vous devez être familier avec les notions de flags et commandes. Dans cette partie, nous allons apprendre à gérer les flags avec un utilitaire courant et souvent installer par défaut sur les systèmes Linux : getopt.
  </para>
  <para/>
  <section>
    <title>Get Opt</title>
    <para/>
    <para>
      Get Opt est un utilitaire bash (installé par défaut). Cependant, sous Mac OS, la version getopt de base ne supporte pas les longs flags (ex : --help pour -h). Comme dit au début de l'article, il faut installer gnu-getpot pour avoir leur support via getopt. Getopt va nous permettre de définir des arguments courts et longs ainsi que les s'ils attendent un paramètre ou non.
    </para>
    <para/>
    <para>
      <section>
        <title>La syntaxe</title>
        <para/>
        <para>
          Pour utiliser getopt, il faut tout d'abord appeler l'utilitaire getopt. Celui prend plusieurs paramètres. Pour notre part, nous utiliserons les paramètres suivants : -o pour définir les options courtes, -l pour définir les arguments longs et -n pour définir le nom du programme. Pour définir les flags courts, il suffit de lister ceux-ci (les flags courts sont systématiquement une lettre seule). Pour les flags longs, il faut les séparer d'une virgule. Enfin, que ce soit pour les arguments longs ou courts, un argument suivi de : attends une option.
        </para>
        <para/>
        <para>
          Un exemple de getop (regroupant les options "classiques") serait :
          <programlisting language="bash">
            getopt -o hv --long help,version -n 'Exemple' -- "$@"
          </programlisting>
          Qui va définir les flags h et v pour help et version. Le -- avant "$@" permet d'introduire un élément pour savoir ou se termine l'entrée des flags. Par la suite, nous allons lire les entrées une à une jusqu'à arriver sur le cas --.
        </para>
      </section>
      <section>
        <title>Utilisation</title>
        <para/>
        <para>
          Reprenons notre programme précédent. Celui-ci était interactif par défaut et permettait de choisir entre afficher une citation ou réaliser un calcul. Maintenant, supposons que l'on veille exécuter un calcul en utilisant ce script, mais de façon automatisée. Il nous est impossible actuellement de donner au programme le calcul à effectuer sans le saisir par nous-mêmes. Ajoutons donc quelque fonctionnalité via getopt pour permettre une utilisation non interactive du script.
        </para>
        <para/>
        <section>
          <title>Avec des flags</title>
        <para>
          Tout d'abord, quelles options allons-nous rajouter. Nous devons déterminer une option ou plusieurs pour pouvoir lancer le programme en mode non interactif. Nous avons alors deux options : utiliser un flag (ex : -i pour le mode interactif) et des commandes ou utiliser deux flags (ex : --calc et --surprise-me pour calculer ou avoir une citation). Nous implémenterons ces deux solutions en commençant par l'option deux flags. Nous allons également ajouter les tags de versions et help (parce que c'est la base non ? ).
        </para>
        <para/>
        <para>
          Nous pouvons intégralement récupérer le code précédemment réaliser. Une seule fonction doit être modifiée : la fonction de calcul. En effet, afin de pouvoir la lancer en mode non interactif, il nous faut pouvoir gérer un argument. Ensuite, il suffit de tester l'argument : si celui-ci vide, nous demandons à l'utilisateur de saisir un calcul. Sinon, nous utilisons l'argument.
        </para>
        <para>
          Ce qui donne :
          <programlisting language="bash">
            #!/bin/bash

            get_citation () {
              local citation_indice=$((RANDOM%4))
              case $citation_indice in
                0) echo "Noob, je suis un noob. Un no-life un vrai. Je joue au MMORPG";;
                1) echo "42";;
                2) echo "Si l'école sa rendait les hommes libres et égaux, le gouvernement déciderait que c'est pas bon pour les marmots.";;
                *) echo "Insérer citation ici";;
              esac
            }

            print_citation () {
              figlet -v &gt; /dev/null 2&gt; /dev/null  &amp;&amp; FIGLET_INSTALLED=0 || FIGLET_INSTALLED=1
              fortun -v &gt; /dev/null 2&gt; /dev/null  &amp;&amp; FORTUNE_INSTALLED=0 || FORTUNE_INSTALLED=1

              if [[ $FORTUNE_INSTALLED -eq 0 ]]
                then CITATION="$(fortune)"
                else CITATION="$(get_citation)"
              fi

              [ $FIGLET_INSTALLED -eq 0 ]  &amp;&amp; figlet -nt "$CITATION" || echo "$CITATION"
            }

            menu () {
              local action_choice="1 - Calculer quelque chose ?
            2 - Etre éclairer par la sagesse de tes ancêtres ?
            3 - Epingle Jésus à sa croix ?"
              local question="Bonjour, jeune scarabée. Dieu te parle et te propose de trouver la voie. As-tu besoin de"
              local not_an_option="Désolé, mais je n'ai pas compris le sens profond de ton interrogation ? Veux-tu ?"
              clean=${1:-0}
              [ $clean -eq 0 ]  &amp;&amp; echo "$question" || echo "$not_an_option"
              echo "$action_choice"
              read -r -n 1 -p "" reponse
              echo
              case $reponse in
                1) calcul;;
                2) print_citation;;
                3) exit 1;;
                *) return 2;;
              esac
            }

            calcul () {
              if [ -z $1 ]
              then
                read -r -p 'Entrez votre calcul : ' response
                echo $[$response]
              else
                echo $[$1]
              fi
            }

            # Two flags implémentation
            # Text Variables
            GET_OPT=`getopt -o hsvc: --long help,surprise-me,version,calculate: -n 'Simple Menu Supinfo Bash article using 2 flags' -- "$@"`
            VERSION="Simple Menu using Getopt version: 0.0.1"
            HELP_MESSAGE="Usage: simple_menu_getopt.sh [OPTIONS]

            Simple menu script used to present bash and getop in a school article.
            This script require getopt to run correctly. (Install gnu-getopt to run from mac).
            By default, process in interactive. Running it with -c or -s option make it non interactive.

            Options:

            -c, --calculate     Run a calcul with the provided argument (ex: -c \"1+2\")
            -h, --help          Print this message
            -s, --surprise-me   Surprise
            -v, --version       Print soft version

            "
            # Exec variable
            c=1; s=1; interactive=0;
            eval set -- "$GET_OPT"
            while true
            do
              case "${1}" in
                -h|--help)
                  echo "$HELP_MESSAGE"; exit 0;;
                -v|--version)
                  echo "$VERSION"; exit 0;;
                -c|--calculate)
                  c=0; expression=$2; interactive=1; shift 2;;
                -s|--surprise-me)
                  s=0; interactive=1; shift 1;;
                --) shift; break;;
                *) echo "Options ${1} is not a known option."; echo "$HELP_MESSAGE" exit 1;;
              esac
            done

            # Proceding
            if [ $interactive -eq 0 ]
            then
              while true
              do
                clean=${clean:-0}
                echo
                menu $clean
                clean=$?
                echo
              done
            else
              [ $c -eq 0 ]  &amp;&amp; calcul $expression
              [ $s -eq 0 ]  &amp;&amp; print_citation
            fi
          </programlisting>
        </para>
        <para/>
        <para>
          Le retour de la commande getopt est ici stocké dans une variable. Par la suite, cette variable est évaluée dans une boucle d'interaction. A chaque étape de la boucle, on regarde l'argument actuellement passé à la fonction puis on le gère avant de le consommer. Dans le cas ou l'argument est terminal, un exit est appelé pour stopper l'exécution de la fonction.
        </para>
        <para/>
      </section>
        <para>
          Voici donc une façon d'utiliser et traiter les flags. Maintenant, voyons comment gérer l'interaction via des fonctions et non plus des flags.
        </para>
        <section>
          <title>Avec des flags et des fonctions</title>
          <para/>
          <para>
            Cette fois, nous allons utiliser un flag -i pour lancer le programme en mode interactif. Par défaut, celui-ci sera donc non interactif et demandera des commandes à lancer. Aussi, pour le programme de calcul, nous allons réutiliser la version modifiée et acceptant un argument. Les fonctions ne pourront plus être cumulé (avec le système de flag, je pouvais effectuer un calcul et afficher une citation en mode non interactif).
          </para>
          <para>
            Précédemment, avec les flags, nous avions une variable pour décider de l'exécution de tel ou tel processus. Ici, nous allons supprimer ces variables et, à la place, définir un format à respecter. Nous lirons ensuite les arguments pour savoir quelle commande l'utilisateur désire exécuter.
          </para>
          <para>
            Ce qui donne :
            <programlisting language="bash">
              #!/bin/bash

              get_citation () {
                local citation_indice=$((RANDOM%4))
                case $citation_indice in
                  0) echo "Noob, je suis un noob. Un no-life un vrai. Je joue au MMORPG";;
                  1) echo "42";;
                  2) echo "Si l'école sa rendait les hommes libres et égaux, le gouvernement déciderait que c'est pas bon pour les marmots.";;
                  *) echo "Insérer citation ici";;
                esac
              }

              print_citation () {
                figlet -v &gt; /dev/null 2&gt; /dev/null &amp;&amp; FIGLET_INSTALLED=0 || FIGLET_INSTALLED=1
                fortune -v &gt; /dev/null 2&gt; /dev/null &amp;&amp; FORTUNE_INSTALLED=0 || FORTUNE_INSTALLED=1

                if [[ $FORTUNE_INSTALLED -eq 0 ]]
                  then CITATION="$(fortune)"
                  else CITATION="$(get_citation)"
                fi

                [ $FIGLET_INSTALLED -eq 0 ] &amp;&amp; figlet -nt "$CITATION" || echo "$CITATION"
              }

              menu () {
                local action_choice="1 - Calculer quelque chose ?
              2 - Etre éclairer par la sagesse de tes ancêtres ?
              3 - Epingle Jésus à sa croix ?"
                local question="Bonjour, jeune scarabée. Dieu te parle et te propose de trouver la voie. As-tu besoin de"
                local not_an_option="Désolé, mais je n'ai pas compris le sens profond de ton interrogation ? Veux-tu ?"
                clean=${1:-0}
                [ $clean -eq 0 ] &amp;&amp; echo "$question" || echo "$not_an_option"
                echo "$action_choice"
                read -r -n 1 -p "" reponse
                echo
                case $reponse in
                  1) calcul;;
                  2) print_citation;;
                  3) exit 1;;
                  *) return 2;;
                esac
              }

              calcul () {
                if [ -z $1 ]
                then
                  read -r -p 'Entrez votre calcul : ' response
                  echo $[$response]
                else
                  echo $[$1]
                fi
              }
              # Avec fonctions
              # Text Variables
              GET_OPT=`getopt -o hiv --long help,interactive,version -n 'Simple Menu Supinfo Bash article using functions' -- "$@"`
              VERSION="Simple Menu using Getopt and Functions version: 0.0.1"
              HELP_MESSAGE="Usage: simple_menu_getopt.sh [OPTIONS] [COMMAND] [ARGUMENTS]

              Simple menu script used to present bash and getop in a school article.
              This script require getopt to run correctly. (Install gnu-getopt to run from mac).
              By default, process in interactive. Running it with -c or -s option make it non interactive.

              Options:

              -i, --interactive   Run the process interactively.
              -h, --help          Print this message.
              -v, --version       Print soft version.

              Command:

              calcul              Make a calcul. If no argument provided, will ask for the user to enter the calcul.
              print_citation      Affiche une citation.
              "

              # Exec variables
              interactive=1;

              # Programm
              eval set -- "$GET_OPT"
              while true
              do
                case "${1}" in
                  -h|--help)
                    echo "$HELP_MESSAGE"; exit 0;;
                  -v|--version)
                    echo "$VERSION"; exit 0;;
                  -i|--interactive)
                    interactive=0; shift 1;;
                  --) shift; break;;
                  *) echo "Options ${1} is not a known option."; echo "$HELP_MESSAGE" exit 1;;
                esac
              done

              if [ $interactive -eq 0 ]
              then
                while true
                do
                  clean=${clean:-0}
                  echo
                  menu $clean
                  clean=$?
                  echo
                done
              else
                case "${1}" in
                  calcul) calcul $2; exit $?;;
                  print_citation) print_citation; exit $?;;
                  *) echo "${1} is not a valid command."; echo "$HELP_MESSAGE"; exit 1;;
                esac
              fi
            </programlisting>
          </para>
          <para>
            Et voilà pour les bases de bash en utilisant getopt. Nous allons maintenant pouvoir faire des choses un peu plus complètes.
          </para>
        </section>
        </para>
      </section>
    </para>
  </section>
  <para/>
  <para>
    Pour finir cet article, je vais donc vous proposer de faire un mini soft pour permettre de gérer des commandes git. Celui-ci doit permettre :
    <itemizedlist>
      <listitem>De vérifier l'installation correcte de git et la présence (optionnelle) d'une clé ssh fonctionnelle.</listitem>
      <listitem>
        De cloner un ou plusieurs répertoire(s) git depuis une url ou le chemin du repo (Nom_Createur/Repo ou Nom_Organisation/Repo) dans le dossier git configurer par l'utilisateur.
      </listitem>
      <listitem>De générer une clé utilisable dans git et mettre la référence publique de cette clé dans le presse papier</listitem>
      <listitem>De mettre à jour tous les répertoires git depuis un dossier (si celui-ci n'est pas fourni en arguments, un fichier de setup doit le contenir)</listitem>
      <listitem>De commit toutes les modifications apportées aux fichiers suivis par les répertoires</listitem>
      <listitem>De commit toutes les modifications apportées aux répertoires</listitem>
      <listitem>De push toutes les modifications possibles depuis un dossier (le même que celui de mise à jour par défaut)</listitem>
      <listitem>De mettre à jour la configuration du programme</listitem>
      <listitem>Protégées des branches afin d'éviter les mises à jour indésirables (via fichier de config et variables). Par défaut la branche master doit être protégée</listitem>
      <listitem>De gérer les branches de base pour les mises à jour (par défaut, master).</listitem>
    </itemizedlist>
    Pour ceux qui ne connaitrait pas git, je vous invite à consulter l'article de Nicolas Bergeron sur le sujet (dans les articles supinfo).
  </para>
  <section>
    <title>Workplace : git manager</title>
    <para/>
    <para>
      Afin de profiter pleinement de cette partie, je vous invite à essayer de coder le système par vous même avant de regarder les solutions proposées.
    </para>
    <para/>
    <para>
      Le code :
      <programlisting language="bash">
#!/bin/bash
###########################################################################
############################## FUNY GIT SOFT ##############################
###########################################################################
## Small bash script to help managing multiple git repository store in a ##
## unique known folder (ex : ~/git).                   ##
###########################################################################
## AUTHOR : Titouan FREVILLE &lt;titouanfreville@gmail.com&gt;         ##
###########################################################################
# -------------------- VARIABLES ------------------------------------------
# ### STYLES ### #
bold="\e[1;"
thin="\e[0;"
# ### COLORS ### #
green="32m"
red="31m"
blue="34m"
basic="\\033[0;39m"
# ### ### #
# ### VERSIONS ### #
TOOL_VERSION="Git Soft : 0.0.1"
# ### ### #
# ### GIT CLONE ROOTS ### #
GIT_CLONE_ROOT_SSH="git@github.com:"
GIT_CLONE_ROOT_HTTP="github.com/"
# ### ### #
# ### HTTP S VARS ### #
HTTP="http://"
HTTPS="https://"
# ### ### #
# ### RUNNER VARIABLE ### #
run=""
base_config="# Associative array declaration
declare -A SPECIFIC_BRANCH_CHECK
declare -A COMMIT_MESSAGE_TABLE

# Locked branches default
LOCKED_BRANCHES=(master develop __PLACE_TO_ADD_BRANCHES__)

# GIT HOME DEFAULT
GIT_HOME=~/git
"
# ### ### #
# ### HELP MESSAGES ### #
# GENERAL -------------------
# ---------------------------
GENERAL_HELP_MESSAGE="Usage : ./git_soft.sh [OPTIONS] COMMAND [COMMAND_OPTIONS] [ARGUMENTS]

Small git soft program to help managing git repo.

WARNINGS:

* On Mac OS, you have to download gnu-getopt so this soft can work.
* The process block by default push on master branch.
  It does not ensure push safety for other branches. You have to configure it by yourself.


Options:

-c, --config    Update configuration to add the provided config.
        Configurations :
        * branch safety : to add a branch as locked, use -c ADD_LOCK=BRANCH_NAME
        * base branch to look : to add a base branch for repositories,
          use -c ADD_BASE=\"FOLDER_PATERN=BRANCH_NAME\"
        Use any other argument to show current config (eg: \"\")
-h, --help    Print this message
-v, --version   Print tool version


Commands:

check_install   Check that git is correctly installed. If git it is not, try to install it. This command require admin rights.
check_ssh       Check if git can be used with ssh clones.
ssh_init        Help you to configure git to add ssh support.
clone           Clone provided git url at root of the default git folder.
update          Go in all git repositorie in default git folder and update them using provided base branch (default is master).
commit          Search for all modification to commit on known files by default (commit -a).
push            Push all commited modifications.
"
# ---------------------------
# CHECK INSTALL -------------
CHECK_INSTALL_HELP_MESSAGE="Usage : ./git_soft.sh [OPTIONS] check_install [COMMAND_OPTIONS]

Check Install function :

Check your that your git installation is ready. If not, install it.

Options:

-h, --help    Print this message.
-i, --init    Init your git to use ssh if not setted.
-s, --ssh     Also check for git ssh corectness.
"
# ---------------------------
# CHECK SSH -----------------
CHECK_SSH_HELP_MESSAGE="Usage : ./git_soft.sh [OPTIONS] check_ssh [COMMAND_OPTIONS]

Check SSH function :

Check your that your git installation can use SSH.

Options:

-h, --help     Print this message.
-i, --init     Init your git to use ssh if not setted.
"
# ---------------------------
# SSH INIT ------------------
SSH_INIT_HELP_MESSAGE="Usage : ./git_soft.sh [OPTIONS] ssh_init [COMMAND_OPTIONS] MAIL_ADDRESS

Ssh Init function :

Initialise your git installation to use ssh using provided email.

Options:

-d, --detached  Run the process as non interactive.
-h, --help      Print this message.
-n, --name      Name for the ssh-key (Used in non interactive mode, default is id_github)
"
# ---------------------------
# CLONE ---------------------
CLONE_HELP_MESSAGE="Usage : ./git_soft.sh [OPTIONS] check_install [COMMAND_OPTIONS] REPO_PATHS/CLONE_URLS ...

Clone function :

Clone git repository passed in arguments using ssh if setted, https else. You can force one mode
by using the -f option. If you use -f, you have to pass the full clone url
(git@github.com:XXXX ou https://github.com/XXXX). If you do not pass the -f tag, please pass only
the path of the repository (Creator/Repository_Name or Organisation/Repository_Name).

Options:

-p, --local-path  Where you want the clone file to be. (Default : GIT_HOME :: ~/git if not changed).
-f, --force       Force clone type using full url.
-h, --help      Print this message.
"
# ---------------------------
# UPDATE --------------------
UPDATE_HELP_MESSAGE="Usage : ./git_soft.sh [OPTIONS] update [COMMAND_OPTIONS]

Update function :

Go through all the git repositories to update git repositories.

Options:

-b, --branch  Add prioritary base branch informations. (-b REPOSITORY_NAME:BRANCH_TO_CHECK)
-h, --help    Print this message.
-l, --locked  Add locked branch for specific repository. (-l REPOSITORY_NAME:BRANCH_TO_LOCK)
"
# ---------------------------
# COMMIT --------------------
COMMIT_HELP_MESSAGE="Usage : ./git_soft.sh [OPTIONS] commit [COMMAND_OPTIONS]

Commit function :

Go through all the git repositories to commit. By default, it commit only known files (commit -a).

Options:

-a, --all
-h, --help    Print this message.
-m, --message Use message for repo. (-m REPO:MESSAGE)
"
# ---------------------------
# PUSH ----------------------
PUSH_HELP_MESSAGE="Usage : ./git_soft.sh [OPTIONS] push [COMMAND_OPTIONS]

Push function :

Go through all the git repositories to push.

Options:

-h, --help    Print this message.
-l, --locked    Add locked branch for specific repository. (-l REPOSITORY_NAME:BRANCH_TO_LOCK)
"
# ---------------------------
# ### ### #
# -------------------------------------------------------------------------
# -------------------- Functionalities ------------------------------------
# ### GIT INSTALLED ### #
check_install_func () {
  echo -e "$thin$ blue Checking if git is correctly installed $basic"
  git --version &gt; /dev/null 2&gt; /dev/null
  if [ $? -eq 0 ]
  then
    echo -e "$bold$green Git est bien installé $basic"
  else
    sudo apt-get install -qy git || echo -e "bold$red Git is not installed $basic"
  fi
}
# ### ### #
# ### SSH ENABLED ### #
check_ssh_func () {
  echo -e "$thin$blue Checking if git is setted up to support ssh $basic"
  ssh -T git@github.com &gt; /dev/null 2&gt; /dev/null
  if [ $? -eq 1 ]
  then
    echo -e "$bold$green Git is ready to use ssh clone. $basic"
    return 0
  else
    echo -e "$bold$red Git is not correctly setted to support ssh. $basic"
    return 1
  fi
}
# ### ### #
# ### INIT SSH ### #
init_ssh_func () {
  echo -e "$thin$blue Initializing git to use ssh $basic"
  local email=$1
  local interactive=${2:-0}
  local key_name=${3:-id_github}
  if [ $interactive -eq 0 ]
  then
    ssh-keygen -t rsa -b 4096 -C $email
  else
    echo -e "$thin$blue Generating ssh key using : $email as mail comment, $HOME/$key_name as path for the new file and without password"
    ssh-keygen -t rsa -b 4096 -C $email -f $HOME/$key_name -q -N "" &amp;&amp; echo -e "$bold$green Key generated in $HOME/$key_name" || { echo -e "$bold$red Failed to generate key"; exit 1; }
  fi
  eval "$(ssh-agent -s)" &gt; /dev/null 2&gt; /dev/null
  ssh-add $HOME/$key_name &amp;&amp; echo -e "$bold$green Key correctly generated and usable. $basic" || { echo -e "$bold$red Failed to add Key to user Agent. Not ready. $basic"; exit 1; }
  xclip -sel clip &lt; $HOME/$key_name.pub &gt; /dev/null 2&gt; /dev/null &amp;&amp; echo -e "$thin$green Public key copied to clipboard. $basic" || echo -e "$thin$red Failed to use xclip. $basic"
  echo -e "$bold$blue Tried to paste the copied key to git (if you don't see key, it mean that it failed). If failed, copy the following lines to github. $basic"
  echo -e "$thin$blue &gt;&gt;&gt; Public key start $basic"
  cat $HOME/$key_name.pub
  echo "$thin$blue &gt;&gt;&gt; Public key end $basic"
}
# ### ### #
# ### CLONE ### #
multi_way_cloning () {
  local clone_path=$1
  git clone $GIT_CLONE_ROOT_SSH$clone_path &gt; /dev/null 2&gt; /dev/null \
  &amp;&amp; echo -e "$clone_path well cloned using SSH$basic" \
  || { git clone $HTTPS$GIT_CLONE_ROOT_HTTP$clone_path 1&gt; /dev/null \
  &amp;&amp; echo -e "$bold$green $clone_path well cloned using HTTP$basic" \
  || echo -e "$bold$red Error why cloning $clone_path. Can't clone with either HTTP or SSH. $basic"; }
}

clone_func () {
  echo -e "$thin$blue Start cloning $basic"
  local forced=1
  local clone_path=""
  case "$1" in
    0) forced=0;;
    *) forced=1;;
  esac
  shift
  cd $GIT_HOME
  if [ $forced -eq 0 ]
  then
    for arg in $@
    do
      echo -e "&gt;&gt;&gt;$thin$blue Cloning $arg $basic"
      git clone "$arg" 1&gt; /dev/null &amp;&amp; echo -e "$bold$green $arg well cloned$basic" || echo -e "$bold$red Error while cloning : $arg$basic"
    done
  else
    for arg in $@
    do
      echo -e "&gt;&gt;&gt;$thin$blue Cloning $arg $basic"
      case "$arg" in
        http://github.com/*)
          clone_path=${arg##http://github.com/}
          multi_way_cloning "$clone_path"
          ;;
        https://github.com/*)
          clone_path=${arg##https://github.com/}
          multi_way_cloning "$clone_path"
          ;;
        git@github.com:*)
          clone_path=${arg##git@github.com:}
          multi_way_cloning "$clone_path"
          ;;
        */*) multi_way_cloning "$arg"
          ;;
        *) echo -e "$bold$red $arg is not well formated. Please provide a repo path (User/Repo or Organisation/Repo) or the clone url. $basic"
      esac
    done
  fi
}
# ### ### #
# ### UPDATE  ### #
update_action_func () {
  local checkout_branch=$1
  local base_branch=$(git branch | grep \* | cut -d ' ' -f2)
  local checkout=0
  if [[ "${LOCKED_BRANCHES[@]}" == *"${base_branch}"* ]]
  then
    echo -e "$bold$red Only Gods are allowed to break locked branches. You are not god. $basic"
    git pull
    return 666
  fi
  if [[ $checkout_branch == $base_branch ]]
    then checkout=1
  fi
  [ $checkout -eq 0 ] &amp;&amp; git stash
  [ $checkout -eq 0 ] &amp;&amp; git checkout $checkout_branch
  [ $checkout -eq 0 ] &amp;&amp; git checkout $base_branch
  [ $checkout -eq 0 ] &amp;&amp; git merge $checkout_branch
  [ $checkout -eq 0 ] &amp;&amp; git push
  [ $checkout -eq 0 ] &amp;&amp; git stash apply
  [ $checkout -eq 0 ] &amp;&amp; git stash drop stash@{0}
}

update_check_specific () {
  for el in ${!SPECIFIC_BRANCH_CHECK[@]}
  do
    if [[ $1 == *"$el"* ]]
    then
      update_action_func ${SPECIFIC_BRANCH_CHECK[$el]}
      return  0
    fi
  done
  return 1
}

update_check_repo () {
  for repo in $1/*
  do
    if [[ -d ${repo} ]]
    then
      if [[ -d ".git" ]]
      then
        update_check_specific $repo
        if [ $? -ne 0 ]
        then
          update_action_func 'master'
        fi
      fi
      update_check_repo ${repo}
    fi
  done
}
# ### COMMIT ### #
commit_action_func () {
  local message
  local commit="git commit -a"
  local base_branch=$(git branch | grep \* | cut -d ' ' -f2)

  if [ $# -gt 2 ]
  then
    message=$1
    commit="git commit"
  else
    case "$1" in
      0) commit="git commit";;
      1) commit="git commit -a";;
      *) message="$1";;
    esac
  fi

  if [[ "${LOCKED_BRANCHES[@]}" == *"${base_branch}"* ]]
  then
    echo -e "$bold$red Only Gods are allowed to break locked branches. You are not god. $basic"
    return 666
  fi

  if [ -z $message ]
  then
    $commit
  else
    $commit "$message"
  fi
}

commit_check_specific () {
  for el in ${!COMMIT_MESSAGE_TABLE[@]}
  do
    if [[ $1 == *"$el"* ]]
    then
      commit_action_func ${COMMIT_MESSAGE_TABLE[$el]} $2
      return  0
    fi
  done
  return 1
}

commit_check_repo () {
  for repo in $1/*
  do
    if [[ -d ${repo} ]]
    then
      if [[ -d ".git" ]]
      then
        commit_check_specific $repo $1
        if [ $? -ne 0 ]
        then
          commit_action_func $1
        fi
      fi
      commit_check_repo ${repo} $1
    fi
  done
}
# ### PUSH ### #
push_func () {
  for repo in $1/*
  do
    if [[ -d ${repo} ]]
    then
      if [[ -d ".git" ]]
      then
        cd ${repo} &amp;&amp; git push
      fi
      commit_check_repo ${repo} $1
    fi
  done
}
# ### ### #
# -------------------------------------------------------------------------
# -------------------- Commands Functions ---------------------------------
# ### CHECK INSTALL ### #
check_install () {
  local get_opt=`getopt -o his -l help,init,ssh -n 'Funny git script Check Install' -- "$@"`
  local init=1
  local ssh=1
  eval set -- "$get_opt"
  while true
  do
    case "$1" in
      -h|--help)
        echo "$CHECK_INSTALL_HELP_MESSAGE"; exit 0;;
      -s|--ssh)
        ssh=0; shift 1;;
      -i|--init)
        init=0; shift 1;;
      --) shift; break;;
      *) echo "Options ${1} is not a known option."; echo "$CHECK_INSTALL_HELP_MESSAGE"; exit 1;;
    esac
  done
  check_install_func
  [ $ssh -eq 0 ] &amp;&amp; check_ssh_func
  [ $init -eq 0 ] &amp;&amp; { check_ssh_func || init_ssh_func ; }
}
# ### ### #
# ### CHECK SSH ### #
check_ssh () {
  local get_opt=`getopt -o hi -l help,init-n 'Funny git script Check Check SSH' -- "$@"`
  local init=1
  eval set -- "$get_opt"
  while true
  do
    case "$1" in
      -h|--help)
        echo "$CHECK_SSH_HELP_MESSAGE"; exit 0;;
      -i|--init)
        init=0; shift 1;;
      --) shift; break;;
      *) echo "Options ${1} is not a known option."; echo "$CHECK_SSH_HELP_MESSAGE"; exit 1;;
    esac
  done
  check_install_func
  [ $init -eq 0 ] &amp;&amp; { check_ssh_func || init_ssh_func ; } || check_ssh_func
}
# ### ### #
# ### SSH INIT ### #
ssh_init () {
  local get_opt=`getopt -o dhn: -l detached,help,name: -n 'Funny git script Init SSH' -- "$@"`
  local name
  local interactive=0
  eval set -- "$get_opt"
  while true
  do
    case "$1" in
      -h|--help)
        echo "$SSH_INIT_HELP_MESSAGE"; exit 0;;
      -d|--detached)
        interactive=1; shift 1;;
      -n|--name)
        name="$2"; shift 2;;
      --) shift; break;;
      *) echo "Options ${1} is not a known option."; echo "$SSH_INIT_HELP_MESSAGE"; exit 1;;
    esac
  done
  init_ssh_func $1 $interactive "$name"
}
# ### ### #
# ### CLONE ### #
clone () {
  local get_opt=`getopt -o fhp: -l forced,help,local-path: -n 'Funny git script Clone' -- "$@"`
  local path
  local forced=1
  eval set -- "$get_opt"
  while true
  do
    case "$1" in
      -h|--help)
        echo "$CLONE_HELP_MESSAGE"; exit 0;;
      -f|--forced)
        forced=0; shift 1;;
      -p|--local-path)
        path="$2"; shift 2;;
      --) shift; break;;
      *) echo "Options ${1} is not a known option."; echo "$CLONE_HELP_MESSAGE"; exit 1;;
    esac
  done
  clone_func $forced "$path"
}
# ### ### #
# ### UPDATE ### #
update () {
  local get_opt=`getopt -o hl:b: -l help,locked:,branch: -n 'Funny git script Update' -- "$@"`
  local branches_stack
  local locked_stack
  eval set -- "$get_opt"
  while true
  do
    case "${1}" in
      -h|--help)
        echo "$UPDATE_HELP_MESSAGE"; exit 0;;
      -b|--default-branch)
        branches_stack+=($2)
        shift 2;;
      -l|--locked)
      LOCKED_BRANCHES+=($2)
      shift 2;;
      --) shift; break;;
    *) echo "Options ${1} is not a known option."; echo "$UPDATE_HELP_MESSAGE"; exit 1;;
    esac
  done


  if [ ! -z branches_stack ]
  then
    for el in "${branches_stack[@]}"
    do
      if [ ! -z $el ]
      then 
        el_array=(${el//=/ })
        key_array+=(${el_array[0]})
        tab_length=$[tab_length+1]
        SPECIFIC_BRANCH_CHECK[${el_array[0]}]=${el_array[1]}
      fi
    done
  fi

  update_check_repo $GIT_HOME 
}
# ### ### #
# ### COMMIT ### #
commit () {
  declare -A COMMIT_MESSAGE_TABLE
  local get_opt=`getopt -o ham: -l help,all,message: -n 'Funny git script Commit' -- "$@"`
  local all
  local commit_stack
  eval set -- "$get_opt"
  while true
  do
    case "${1}" in
      -h|--help)
        echo "$COMMIT_HELP_MESSAGE"; exit 0;;
      -a|--all)
        all=0
        shift 1;;
      -m|--message)
      commit_stack+=($2)
      shift 2;;
      --) shift; break;;
    *) echo "Options ${1} is not a known option."; echo "$COMMIT_HELP_MESSAGE"; exit 1;;
    esac
  done

  if [ ! -z commit_stack ]
  then
    for el in "${branches_stack[@]}"
    do
      if [ ! -z $el ]
      then 
        el_array=(${el//=/ })
        key_array+=(${el_array[0]})
        tab_length=$[tab_length+1]
        COMMIT_MESSAGE_TABLE[${el_array[0]}]=${el_array[1]}
      fi
    done
  fi
  commit_check_repo $GIT_HOME $all
}
# ### ### #
# ### PUSH ### #
push () {
  local get_opt=`getopt -o hl: -l help,locked: -n 'Funny git script Push' -- "$@"`
  local branches_stack
  local locked_stack
  eval set -- "$get_opt"
  while true
  do
    case "${1}" in
      -h|--help)
        echo "$PUSH_HELP_MESSAGE"
        exit 0;;
      -l|--locked)
      LOCKED_BRANCHES+=($2)
      shift 2;;
      --) shift; break;;
    *) echo "Options ${1} is not a known option."; echo "$PUSH_HELP_MESSAGE"; exit 1;;
    esac
  done
  push_func $GIT_HOME
}
# ### ### #
# -------------------------------------------------------------------------
# -------------------- Runner ---------------------------------------------
GET_OPT=`getopt -o hvc: -l help,version,config: -n "Git management helper." -- "$@" 2&gt; /dev/null`
if [ ! -f ~/.git_helper_config ]
then
  echo "$base_config" &gt; ~/.git_helper_config
fi

source ~/.git_helper_config

# cat ~/.git_helper_config
echo
eval set -- "$GET_OPT" 2&gt; /dev/null
while true
do
  case "${1}" in
    -h|--help)
      echo "$GENERAL_HELP_MESSAGE"; exit 0;;
    -v|--version)
    echo "$TOOL_VERSION"; exit 0;;
    -c|--config)
    config_state="new"
    config_stack=(${2//=/ })
    case "${config_stack[0]}" in 
      ADD_LOCK) sed -i "s/__PLACE_TO_ADD_BRANCHES__/${config_stack[1]} __PLACE_TO_ADD_BRANCHES__/g" ~/.git_helper_config;;
      ADD_BASE) 
        echo "SPECIFIC_BRANCH_CHECK[${config_stack[1]}]=${config_stack[2]}" &gt;&gt; ~/.git_helper_config
        ;;
      *) config_state="current";;
    esac ;

    echo "$config_state config is :
    "
    cat ~/.git_helper_config
    exit 0;;
    --)run="$2"; shift 2; break;;
  *) echo "Options ${1} is not a known option."; echo "$PUSH_HELP_MESSAGE"; exit 1;;
  esac
done

$run $@
# -------------------------------------------------------------------------
      </programlisting>
    </para>
    <para/>
  </section>
  <para>
  </para>
  <para>
    Voici donc pour cet article. J'espère que vous aurez appris de nouvelles choses :) Je vous laisse le lien vers mon répertoire git où vous pourrez retrouver tous les fichiers de codes présenter ici.
  </para>
  <para>
    <itemizedlist>
      <listitem>
        <ulink href = "http://github.com/titouanfreville/Supinfos_Articles/tree/master/ocaml_article/ressources">Les codes de l'article</ulink>
      </listitem>
    </itemizedlist>
  </para>
  <para/>
</section>
