<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<section>
  <title>La programmation fonctionnelle et Elixir</title>
  <para/>
  <section>
    <title>Introduction</title>

    <para/>

    <para>
      Cet article a pour but de vous présenter un nouveau langage (Elixir <ulink url="http://elixir-lang.org/">http://elixir-lang.org/</ulink>) et le concept de programmation fonctionnelle.</para>
    <para/>

    <para>
      Je vais tout d'abord rappeler ce qu'est la programmation fonctionnelle. Je vous invite à consulter les cours et vidéo à ce sujet si vous accés aux ressources de Supinfo pour plus de détails (cf 3AIT notemment) ainsi que les articles suivants :
      <ulink url="http://www.supinfo.com/articles/single/1572-programmer-elixir"> http://www.supinfo.com/articles/single/1572-programmer-elixir</ulink>, <ulink url="https://fr.wikipedia.org/wiki/Programmation_fonctionnelle">https://fr.wikipedia.org/wiki/Programmation_fonctionnelle</ulink> et <ulink url="http://deptinfo.unice.fr/~roy/progfonc.html">http://deptinfo.unice.fr/~roy/progfonc.html</ulink> 
    </para>

    <para/>
  </section>
  <section>
    <title>La programmation fonctionnelle, en bref.</title>
    <para/>
    <para>
      Il est plus simple de parler de programmation fonctionnelle par opposition à la programmation impérative, plus connues et abordée plus tôt dans les programmes scolaires. Si vous ne savez pas ce qu'est la programmation impérative, je vous invite à ignorer ce paragraphe pour passer directement à l'introduction d’Élixir après avoir lue ou regarder les articles et ressources précédemment cités.
    </para>
    <section>
      <title>Concept de programmation fonctionnelle.</title>
      <para>
        La programmation fonctionnelle est un concept de programmation ayant pour but principal de s'affranchir des problèmes d'affectation présent dans la programmation impérative. Ainsi, en programmation fonctionnelle, nous n'utilisons plus des états de la machine (ex : x=1 =&gt; J'ai créer un entier référencer par x dont la valeur est 1 donc ma machine est dans l'état X. x++ -&gt;x vaut maintenant 2, ma machine est dans un nouvel état Y.) mais des fonctions imbriquées. La principale différence étant que : En programmation fonctionnelle, je sais exactement ce que FAIT mon programme et comment il évolue LOGIQUEMENT (essentiellement basée sur les concepts de récursion en mathématiques) tandis que en programmation impérative, je sais dans quel état est ma machine, ce qui est présent en mémoire (à qu'elle endroit dans les langages de plus bas niveaux) et quel état je dois atteindre. D'un côté, je sais COMMENT mon programme fonctionne (impératif), de l'autre, je sais POURQUOI et je peux le démontrer (fonctionnel).
      </para><para>
        Une autre différence : il est possible, en programmation impérative, de modifier plusieurs Pointeurs dans une même fonctions (et donc d'avoir d'une certaine façon, une fonction qui 'retourne' plusieurs valeurs). C'est impossible en programmation fonctionnel. Une fonction en programmation fonctionnel prend des ensembles d'arguments (liste, tuples, singleton, etc.) et ne retourne qu'un seul ensemble.
      </para>
    </section>
    <section>
      <title>Utilisations de la programmation fonctionnelle.</title>
      <para/>
      <para>
        La programmation fonctionnelle est aujourd'hui principalement utilisée dans deux domaines :
        <itemizedlist>
          <listitem>
            <para>
              Les preuves, démonstrations et calculs dans le domaine scientifique (ex : démontrer la validité d'un concept mathématique)
            </para>
          </listitem>
          <listitem>
            <para>
              L'intelligence artificielle (IA). (cf cours 3AIT)
            </para>
          </listitem>
        </itemizedlist>
        Pourquoi ces deux domaines ? Pour la partie scientifique, les langage de programmation fonctionnelle cherchant à être aussi proche que possible des bases mathématiques, il est logique de les utiliser pour des applications et programmes liées à ce domaines. Pour son utilisation en intelligence artificielle, l'IA est un domaine ou l'algorithmie occupe une place centrale. Or en programmation fonctionnelle, si l'algorithme implémenter fait ce que nous voulons, et qu'il est correctement implémenter, nous pouvons être sur qu'il fera ce qu'il faut.
      </para>
    </section>
    <para/>
    <para>
      Ceci étant fixer, présentons maintenant Élixir. Pour cela, je vous invite à consulter la page web officiel du langage (<ulink url="http://elixir-lang.org/">http://elixir-lang.org/</ulink>) et suivre le GETTING STARTED. Pour ceux qui ne comprendrait pas l'anglais, sachez qu'Elixir est un langage basé sur Erlang ayant pour objectif d'être puissant (et bien sur, implémentant tout les concepts de programmation fonctionnelle).
    </para>
  </section>
  <section>
    <title>PRÉREQUIS</title>
    <para/>
    <para>
      Pour la suite du voyage, il vous faudra avoir : 
      <itemizedlist>
        <listitem>
          Installer Élixir sur votre local ou avoir une solution pour compiler et exécuter les programmes.
        </listitem>
        <listitem>
          Avoir un éditeur de texte avec la coloration syntaxique pour Élixir (parce que c'est plus agréables). J'utilise pour ma part Sublime Text 3 avec le package Élixir basique. 
        </listitem>
        <listitem>
          Être prêt à souffrir ;)
        </listitem>
      </itemizedlist>
    </para>

    <para>
      Nous allons apprendre Élixir en suivant les étapes :
      <itemizedlist>
        <listitem>
          Premiers pas : Faire une fonction arithmétique simple
        </listitem>
        <listitem>
          Manipuler les listes 
        </listitem>
        <listitem>
          Fonctions de tri sur les listes
        </listitem>
        <listitem>
          Résolution de problèmes de façon fonctionnelle (ex Tour de Hanoï)
        </listitem>
        <listitem>
          Manipulation simple d'arbre
        </listitem>
      </itemizedlist>
      Les codes seront présentés de façon à être réutilisable via la création de librairie. Tous ce qui va être aboder par la suite sont des concepts et applications basiques de la programmation fonctionnelle. 
    </para>
    <para/>
  </section>
  <section>
    <title>Jouons avec Élixir</title>
    <para/>
    <section>
      <title>A petits pas</title>
      <para/>
      <para>
        Pour cette première expérience, nous allons créer deux fonctions mathématiques : Factorielle (!) et Puissance. Ces fonctions seront implémenter de 2 façons : avec des boucles (classique en impératif) en C, de façon récursive (idéologie fonctionnelle) en Élixir.
        Mais tout d'abord, quelques rappels : 
        <itemizedlist>
          <listitem>
            <para>
              Élixir est un langage purement fonctionnel. Il n'existe pas de syntaxe pour les boucles en Élixir :)
            </para>
          </listitem>
          <listitem>
            <para>
              Élixir est un langage dynamiquement typé. C'est à dire que le type de la variable est déterminer après son affectation. 
            </para>
          </listitem>
          <listitem>
            <para>
              Il faut manipuler les types avec précaution. En effet, chaque fonction attendra un certains type données. Afin d'être le plus réutilisable possible, les fonctions proposés auront toujours une dépendance de type minimal (ex : une fonction d'addition sera typés pour être utilisable par tous floats même si elle utilisé principalement sur des entiers dans notre cas)...
            </para>
            <para>
              Afin que tous sache les prérequis de chaque fonction et sont utilités, celles ci seront commenter comme suit :        
              <programlisting langage="exs">
# @name: Nom_de_la_fonction
# @ Description_de_la_fonction
# @parameter: Nom_du_paramètre Type Description
# ....
# @return: Description (Ce que retourne la fonction, dans quelle situation)
# @throw: Erreur Description
              </programlisting>
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para/>
      <section>
        <title>En mode Impératifs</title>
        <section>
          <title>Théorie</title>
          <para>
            Nous avons dit plus haut que l'algorithme était essentiel en programmation fonctionnel. Bien que ce ne soit pas le cas en programmation impérative, je vous propose de tout de même les écrire en pseudo code afin d'avoir une base de comparaison pour les algorithme donner en fonctionnel.
          </para>
          <para>
            Les algorithmes impératif permettant d'exécuter nos deux fonctions sont les suivants. 
          </para>
          <para>
            <programlisting>
puissance :  
Soit PUISSANCE (a,b) une fonction sur les entiers Naturels. 
PUISSANCE (a,b) = 
Soit res un entier tel que res = 1 
SI b strictement plus petit que 1, Retourner res.  
Si non 
Pour i allant de 1 à b faire : 
  res = res * a  
Fait;  
Retourner res. 
            </programlisting>
          </para>
          
          <para>
            <programlisting>
factorielle :  
Soit FACTORIELLE (a) une fonction sur les entiers Naturels. 
PUISSANCE (a,b) = 
Soit res un entier tel que res = 1   
Pour i allant de 1 à a faire : 
  res = res * a 
Fait; 
Retourner res.
            </programlisting>
          </para>
        </section>
        <section>
          <title>En C</title>
          <para>
            Implémentation en C
          </para>
          <para>
            <programlisting langage="c">
int Puissance(int a, int b)  {
  int res=1;
  int i;
  for (i=1; i&gt;b;i++) {
    res=res*b;
  }
  return res;
}
            </programlisting>
          </para>
          <para>
            <programlisting langage="c">
int Factorielle(int a)  {
  int res=1;
  int i;
  for (i=0; i&gt;a;i++) {
    res=res*i;
  }
  return res;
}
            </programlisting>
          </para>
        </section>
      </section>
      <section>
        <title>En fonctionnel</title>
        <section>
          <title>Algorithme</title>
          <para>
            Les algorithme fonctionnel sont les suivants :
          </para>
          <para>
            <programlisting>
puissance: 
Soit PUISSANCE (a,b) une fonction sur les entiers Naturels,  
PUISSANCE (a,b) = SELON b   
b = 0 -&gt; 1  
b -&gt; a*PUISSANCE (a,b-1) 
            </programlisting>
          </para>
          <para>
            L'idée de cet algorithme récursif est le suivant: à chaque étape, on regarde si b est égale à 0. Si il est égale à 0, on renvoie la valeur 1. Sinon, on renvoie la valeur a multiplié par la valeur renvoyer par Puissance (a, b-1). Comme b diminue à chaque étape, on va nécessairement arriver au cas ou b=0 (que l'on appelle cas simple ou cas de base). Et pour parvenir à cette étape, on aura multiplier a par lui même b fois puis par 1. Ce qui est la définition de la puissance (la puissance mathématique est naturellement récursive, comme beaucoup d'outils mathématiques).
          </para>
          <para>
            <programlisting>
factorielle : 
Soit FACTORIELLE (a) une fonction sur les entiers Naturels, 
FACTORIELLE (a) = SELON a 
a = 0 -&gt; 1 
a -&gt; a*FACTORIELLE (a-1)
            </programlisting>
          </para>
          <para>
            Cet algorithme fonctionne comme le précédent, si ce n'est que l'on a un paramètre unique. On aura donc multiplier a par (a-1) par (a-2) par ... par 1.
          </para>
        </section>
        <section>
          <title>En Élixir</title>
          <para>
            Implémentation en Élixir
          </para>          
          <para>
            <programlisting langage="elixir">
defmodule Maths do
  # @name puissance
  # Fonction permettant de calculer la valeur de a^b. 
  # @param a int entier dont on cherche la puissance
  # @param b int entier représenter la puissance à la quelle élever a
  # @return a^b
  def puissance(a, b) do
    cond do
      b==0 -&gt; 1
      true -&gt; a * puissance(a, b-1)
    end
  end
  # @name factorielle
  # Fonction permettant de calculer la valeur de a!. 
  # @param a int entier dont on cherche la factorielle
  # @return a!
  def factorielle(a) do
    cond do
      a==0 -&gt; 1
      true -&gt; a * factorielle(a-1)
    end
  end
end 
            </programlisting>
          </para>
          <para>
            Si vous avez lue et suivie le Getting Stared d'Élixir, vous aurez vue les fonctions récursive sous une forme un peu différente, propre à Élixir : 

            <programlisting langage="exs">
defmodule Maths do
  # @name factorielle
  # Fonction permettant de calculer la valeur de a!. 
  # @param a int entier dont on cherche la factorielle
  # @return a!
  def factorielle(0) do
    1
  done

  def factorielle(a) do
    a * factorielle(a-1)
  done
end 
            </programlisting>

            Cette forme est tout aussi fonctionnelle, mais plus lourde à écrire, aussi préférerais-je la version que j'ai moi même proposé. À vous de choisir ce qui vous convient le mieux. 
          </para>
        </section>
      </section>
      <para>
        Nous venons donc de réaliser deux fonctions mathématiques simple, une fois en fonctionnel, une fois en impératif. On peut dors et déjà pointé quelque différence entre ces deux visions de programmation : 
        Au niveau de la preuve d'algorithme (ici fait de façon grossière par une explication logique), l'algorithme fonctionnel n'est pas mathématiquement démontrables (il existe des méthodes de preuves pour de tels algorithme, mais elle définissent de nouveau axiomes) contrairement aux algorithme fonctionnel qui sont des algorithme mathématique. C'est l'une des principales différences entre ces deux visions de la programmation, et la raison de préférer l'un à l'autre. Si vous avez besoin d'être certains de comment, et où sont stocker les éléments dans votre ordinateur, comment est utiliser la mémoire, etc., la programmation impérative est la plus adapté. Par contre, si vous avez besoin d'être sur que votre programme va fonctionner comme attendu et être capable de le démontrer simplement, la programmation fonctionnelle est plus adapté.
      </para>
    </section>
    <section>
      <title>Listes</title>
      <para/>
      <para>
        La structure de listes est une structure mathématique naturellement récursive. En effet, une liste est un ensemble d'élément telle que l'on ne peut accéder qu'à l'élément en tête de la liste (le dernier entré). Une liste sera donc représenter ainsi : Liste = Tête :: Queue dans les algorithme. Dans un premier temps, nous allons apprendre à manipuler ce type de structure puis nous verrons ce qu'il est possible de faire dessus. 
      </para>
      <para/>
      <section>
        <title>Manipuler des listes.</title>
        <para>
          Nous avons dit que les listes était des structures récursive (ou inductive). Pour construire une liste, on "empile" des éléments les uns au dessus des autres puis on les dépiles. Il convient donc de manipuler principalement via des fonctions récursive. Si il est possible de recréer des listes et leurs opérateurs dans des langages impératif (tel que C ou JAVA), ce n'est pas une façon "logique" pour stocker des éléments en impératif (on utilisera plutôt des tableaux, permettant d'accéder directement à tous les éléments). Par contre, les listes sont des structures natives en programmation fonctionnelle. La structure est dynamique et sera souvent utiliser pour stocker un ensemble d'élément amené à être régulièrement modifier. Si non, les tuples (que nous verront plus tard) seront des structures plus appréciées. 
        </para>
        <para/>
        <section>
          <title>Premières armes</title>
          <para/>
          <para>
            Commençons par manipuler simplement des listes
          </para>
          <section>
            <title>Affichons tous les éléments d'une liste simple (ne contenant que des singletons)</title>
            <para>
              Voyons comment lire une liste et en afficher chaque éléments. 
            </para>
            <para>
              Tout d'abord, l'algorithme : 
              <programlisting>
                Soit L une liste. 
                Soit F une fonction de X Liste dans Vide (ou X est un type quelconque).
                F (l) = Selon l
                Vide(l) -&gt; Rien à faire ou afficher Vide selon les envies (On est arrivé au bout de liste puis ce qu'elle est vide).
                NonVide(l) -&gt; Afficher Tête(l); F (Queue (l)). (On affiche le premier élément de la liste puis on rappelle la fonction avec la suite de la liste).
              </programlisting>
            </para>
            <para>
              On se contente de prendre le premier élément que l'on trouve pour l'afficher, puis on passe à la suite. Le cas de base est vide car il n'a rien à faire.
            </para>
            <para>
              Le code en élixir : 
              <programlisting langage="exs">
                defmodule Listes do
                  # @name affiche
                  # Fonction permettant d'afficher chaque élément de la liste sous la forme E\nE\nE...Vide
                  # @param l liste liste d'élément à afficher
                  def affiche(l) do
                    cond do
                      l==[] -&gt; IO.puts "Vide"
                      true -&gt; 
                        IO.puts (hd l)
                        affiche(tl l)
                    end
                  end
                end 
            </programlisting>
            </para>
            <para>
              Cette fonction affichera tout les éléments d'une liste en passant à la ligne entre chaque éléments. C'est une fonction basique qui permet surtout de voir comment manipuler une liste. Maintenant, travaillons sur des listes.
            </para>
          </section>
          <section>
            <title>Fonctions de recherche et spécifications</title>
            <para>
              Nous allons implémenter les fonctions suivantes : Recherche d'un élément e dans une liste, suppression des doublons dans une liste puis comptage du nombre d'occurrence (nombre de fois ou il apparaît) d'un élément placer en paramètre. Mais tout d'abord, les algorithmes :).
            </para>
            <section>
              <title>Les algorithmes</title>
              <para>
                Recherche d'une élément : 
                Le concept est simple. On parcourt la liste jusqu'à ce que l'on trouve l'élément chercher. On a donc : 
                <programlisting>
                  Soit Recherche un fonction dans Booléen (Vrai ou Faux). 
                  Recherche(Élément, Liste) = Selon (Liste) 
                  Vide(Liste) -&gt; Faux 
                  NonVide(Liste) -&gt; Tête(Liste) = Éléments ou alors Recherche(Éléments, Queue(Liste)) 
                </programlisting>
              </para>
              <para>
                Suppression des doublons dans une liste : 
                Cette fois, on va parcourir la liste et, pour chaque élément, appeler la fonction de recherche. Si l'élément est encore dans la liste, on passe au suivant, sinon, on passe au suivant en ajoutant l'élément courant à la liste de retour. Ce qui donne : 
                <programlisting>
                  Soit SupDoublons une fonctions dans X Liste
                  SupDoublons(l) = Selon l 
                  Vide(l) -&gt; Vide
                  NonVide(l) -&gt; Si Recherche(Tête(l),Queue(l)) alors SupDoublons(Queue(l)) ou alors Construire Tête(l) (SupDoublons(Queue(l)))
                </programlisting>
              </para>
              <para>
                Nombre d'occurrence de E dans L :
                <programlisting>  
                  Soit NombreDe une fonction dans int (entiers)
                  NombreDe(E,L) = Selon (L) 
                  Vide(L) -&gt; 0
                  NonVide(L) -&gt; Si Tête(L)=E alors 1 + NombreDe(E,Queue(L)) sinon NombreDe(E,Queue(L))
                </programlisting>
              </para>
              <para/>
            </section>
            <para>
              Place au code.
            </para>
            <section>
              <title>Code Ex</title>
              <para>
                <programlisting langage="exs">
                  defmodule Listes do
                    # @name est_dans
                    # Fonction testant la présence d'un élément dans une liste
                    # @param e any élément à rechercher
                    # @param l list liste dans la quelle cherché l'élément
                    # @return true si l'élément existe, false sinon
                    def est_dans(e,l) do
                      cond do
                        l==[] -&gt; false
                        true -&gt; (hd l) == e || est_dans e,(tl l)
                      end
                    end
                    # @name doublons_sk
                    # Fonction permettant de supprimer les doublons dans une liste.
                    # @param l liste liste dont on veux supprimer les doublons.
                    # @return liste sans doublons.
                    def doublons_sk(l) do
                      cond do
                        l==[] -&gt; []
                        true -&gt; if est_dans (hd l),(tl l) do doublons_sk (tl l) else [hd l] ++ doublons_sk (tl l) end
                      end
                    end
                    # @name nb_de
                    # Fonction pour trouver le nombre d’occurrence de E dans L
                    # @param e any éléments à compter
                    # @param l list liste dans la quelle compter
                    # @return nombre d’occurrence de E dans L
                    def nb_de(e,l) do
                      cond do
                        l==[] -&gt; 0
                        true -&gt; (hd l) == e &amp;&amp; 1 + nb_de(e,(tl l)) || nb_de(e,(tl l))
                      end
                    end
                  end 
                </programlisting>
              </para>
              <para>
                Vous voilà désormais armé de quelque fonctions basique sur les listes. Vous pouvez compléter ces fonctions avec des fonctions pour inverser la liste par exemple. Et nous allons tout de suite compléter notre collection avec quelque fonction un peu plus amusantes :)
              </para>
            </section>
          </section>
        </section>
        <section>
          <title>Les fonctions de tri, de l'élèves au maître.</title>
          <para>
            Voyons maintenant deux fonctions de tri sur les listes. La première est la fonction basique de trie. Il est déconseillé de l'utiliser, elle est particulièrement peu efficace. Nous allons également profité de ces fonctions de tri pour voir les 2 méthodologies d'implémentation pour les fonctions récursive. Jusqu'à présent, nous avons empiler les opérations dans les algorithmes et programmes au niveau de l'appel récursif. C'est ce que l'on appel de la récursivité non terminale, car au moments de l'appel récursif, il y a encore des opérations à effectuer. L'avantage de cette façon de faire est qu'elle est logique vis à vis de la récursivité mathématique. L'inconvénient, c'est que cela prend vite beaucoup de place dans la mémoire de notre environnement. Aussi, pour éviter cela, une autre façon de faire, la récursivité terminale existe. Dans ce cas, l'objectif est que au moment de l'appel récursif, le programme n'est plus d'opération à exécuter. Il va donc être nécessaire d'utiliser des accumulateurs. Nous allons utiliser la première fonction de tri (que l'on va appeler tri_bulles) pour illustrer cette différence. 
          </para>
          <para/>
          <section>
            <title>Tri Bulle</title>
            <para/>
            <para>
              La fonction tri bulle est la fonction de tri la plus 'instinctive'. Elle ce contente de regarder chaque éléments puis dans les insérer dans la liste triée. 
            </para>
            <para>
              Nous allons donc avoir l'algorithme suivant en fonctionnel non terminal : 
              <programlisting>
Soit tribulle une fonction dans listes.
tribulle(l) = Selon l
Vide(l) -&gt; Vide
NonVide(l) -&gt; Faire 
  Soit ltriée = tribulle(Queue l) dans
  Si Tête(l) &lt; Tête(ltriée) alors Construire Tête(l) ltriée sinon Construire Tête(ltriée) tribulle(Construire Tête(l) Queue(ltriée))
              </programlisting>
              et celui-ci en récursif terminal :
              <programlisting>
Soit tribulle une fonction dans listes.
tribulle(l, acc) = Selon l
Vide(l) -&gt; acc
NonVide(l) -&gt; Faire 
  Si Tête(l) &lt; Tête(acc) alors Construire Tête(l) acc sinon Construire Tête(acc) tribulle(Construire Tête(l) Queue(acc))
              </programlisting>
            </para>
            <para>
              Nous voyons bien sur cet exemple que les deux façons de procédés on globalement le même fonctionnement. Ici, dans les deux cas, on compare l'élément courant à une liste déjà triée (soit l'accumulateur, soit le tri de la suite de la fonction). On voit aussi, pour cette fonction qu'il n'y a pas de gain de temps quelque soit la solution. Une fonction en récursif terminal et une fonction en récursif non terminal auront, si elles sont bien pensée, le même temps d'exécution. Cependant, l'espace n'est clairement pas occupé de la même façon. Dans la récursivité terminal, on demande au programme de travailler avec un espace mémoire connue représenter par l'accumulateur, et c'est ce paramètre que l'on fait varié à chaque étape. En non terminal, on demande à la pile d'exécution (généralement, cela va se traduire par une occupation de la RAM et de la mémoire processeur) de garder en mémoire les actions à effectuer une fois que l'on aura atteint un cas connue. Vous pourrez voir en testant les programmes que nous allons maintenant élaboré que en la méthode non terminale finira par échouer si vous lui passer une liste trop grosse. Mais vous pourrez aller beaucoup plus loin en utilisant la méthode terminale. 
            </para>
            <para/>
            <para>
              Le code :
              <programlisting langage="elixir">

              </programlisting>
            </para>
          </section>
        </section>
      </section>
    </section>
  </section>
</section>
